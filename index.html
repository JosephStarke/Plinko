<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PLINKO BURN</title>
    <style>
        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #2C1B18;
            color: white;
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
            background-image: linear-gradient(to bottom, #3B1D15, #2C1B18);
            min-height: 100vh;
            touch-action: manipulation;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 5px;
            color: #FF6B35;
            text-shadow: 0 0 20px rgba(255, 107, 53, 0.8), 4px 4px 0px #7A1C00;
            text-align: center;
            letter-spacing: 2px;
            transform: rotate(-2deg);
        }
        
        @media (max-width: 768px) {
            h1 {
                font-size: 2.2rem;
            }
        }
        
        .creator-credit {
            font-size: 1rem;
            color: #FFA15A;
            text-align: center;
            margin-bottom: 15px;
            font-style: italic;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        .game-container {
            position: relative;
            width: 800px;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #3B2723;
            border-radius: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(255, 107, 53, 0.3);
            padding: 20px;
            border: 5px solid #4A2F2A;
            box-sizing: border-box;
            transform-origin: top center;
        }
        
        /* Scale down the entire game on smaller screens while keeping original dimensions */
        @media (max-width: 840px) {
            .game-container {
                transform: scale(0.95);
                margin-bottom: 20px;
            }
        }
        
        @media (max-width: 768px) {
            .game-container {
                transform: scale(0.85);
                margin-bottom: 40px;
            }
        }
        
        @media (max-width: 680px) {
            .game-container {
                transform: scale(0.75);
                margin-bottom: 60px;
            }
        }
        
        @media (max-width: 600px) {
            .game-container {
                transform: scale(0.65);
                margin-bottom: 80px;
            }
        }
        
        @media (max-width: 520px) {
            .game-container {
                transform: scale(0.55);
                margin-bottom: 100px;
            }
        }
        
        @media (max-width: 440px) {
            .game-container {
                transform: scale(0.45);
                margin-bottom: 120px;
            }
        }
        
        @media (max-width: 360px) {
            .game-container {
                transform: scale(0.38);
                margin-bottom: 140px;
            }
        }

        .stats {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 15px;
            position: relative;
            z-index: 2;
            flex-wrap: wrap;
            gap: 10px;
        }

        .score, .balls-left {
            font-size: 1.5rem;
            background-color: #2A1A15;
            padding: 10px 20px;
            border-radius: 15px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5), 0 0 10px rgba(255, 107, 53, 0.3);
            font-weight: bold;
            transition: all 0.5s ease;
            flex: 1;
            min-width: 120px;
            text-align: center;
        }
        
        .score.game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            padding: 30px 40px;
            background-color: rgba(42, 26, 21, 0.9);
            border: 5px solid #FF6B35;
            z-index: 100;
            width: 80%;
            text-align: center;
            animation: flameFlicker 2s infinite alternate;
        }
        
        @keyframes flameFlicker {
            0% { box-shadow: 0 0 20px rgba(255, 107, 53, 0.6); }
            100% { box-shadow: 0 0 40px rgba(255, 107, 53, 0.9); }
        }

        .score span, .balls-left span {
            color: #FF8C5A;
            font-weight: bold;
        }
        
        .drop-buttons {
            display: flex;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        #config-panel {
            width: 100%;
            background-color: #2A1A15;
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3), 0 0 15px rgba(255, 107, 53, 0.2);
            display: none;
            transition: all 0.3s ease;
            overflow-x: hidden;
            max-height: 80vh;
            overflow-y: auto;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
        }

        .config-item label {
            margin-bottom: 8px;
            font-size: 1rem;
            color: #FF8C5A;
        }

        .config-item input, .config-item select, .config-item textarea {
            padding: 10px;
            border-radius: 10px;
            border: 2px solid #4A2F2A;
            background-color: #3A2520;
            color: white;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 16px; /* Better size for mobile inputs */
        }

        .config-item input:focus, .config-item select:focus, .config-item textarea:focus {
            outline: none;
            border-color: #FF6B35;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.6);
        }

        .action-btn {
            margin-top: 5px;
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background-color: #FF6B35;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 1.1rem;
            box-shadow: 0px 4px 0px #7A1C00, 0px 6px 10px rgba(0, 0, 0, 0.4);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
            min-width: 80px;
            white-space: nowrap;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .action-btn:hover {
            background-color: #FF8C5A;
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px #7A1C00, 0px 10px 20px rgba(0, 0, 0, 0.4);
        }

        .action-btn:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px #7A1C00, 0px 4px 5px rgba(0, 0, 0, 0.4);
        }

        .edit-mode {
            padding: 12px 20px;
            border: none;
            border-radius: 15px;
            background-color: #2196F3;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 1.1rem;
            box-shadow: 0px 4px 0px #0B5394, 0px 6px 10px rgba(0, 0, 0, 0.4);
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.4);
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }

        .edit-mode:hover {
            background-color: #4DABF5;
            transform: translateY(-2px);
            box-shadow: 0px 6px 0px #0B5394, 0px 10px 20px rgba(0, 0, 0, 0.4);
        }

        .edit-mode:active {
            transform: translateY(2px);
            box-shadow: 0px 2px 0px #0B5394, 0px 4px 5px rgba(0, 0, 0, 0.4);
        }

        .edit-mode.active {
            background-color: #F44336;
            box-shadow: 0px 4px 0px #B71C1C, 0px 6px 10px rgba(0, 0, 0, 0.4);
        }

        .edit-mode.active:hover {
            background-color: #FF5252;
            box-shadow: 0px 6px 0px #B71C1C, 0px 10px 20px rgba(0, 0, 0, 0.4);
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 600px;
            overflow: hidden;
            border-radius: 20px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(255, 107, 53, 0.2);
            background-color: #241914;
            box-sizing: border-box;
        }

        canvas {
            display: block;
            background-color: transparent;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #particles-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #drop-zones {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50px;
            display: flex;
            justify-content: space-around;
            padding: 0 20px;
            box-sizing: border-box;
        }

        .drop-zone {
            width: 30px;
            height: 30px;
            background-color: rgba(255, 107, 53, 0.3);
            border: 2px solid #FF6B35;
            border-radius: 50%;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            color: white;
            -webkit-tap-highlight-color: transparent;
        }

        .drop-zone:hover {
            background-color: rgba(255, 107, 53, 0.6);
            transform: scale(1.1);
        }

        .buckets {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100px;
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
        }

        .bucket {
            width: 60px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 1.2rem;
            color: #FFD700;
            position: relative;
            cursor: pointer;
            transition: transform 0.2s;
            -webkit-tap-highlight-color: transparent;
        }

        .bucket-hole {
            width: 50px;
            height: 10px;
            background-color: transparent;
            border-bottom: 3px solid #FF6B35;
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            overflow: hidden;
            box-shadow: 0 0 10px rgba(255, 107, 53, 0.4);
        }

        .bucket-hole::before {
            content: "";
            position: absolute;
            width: 100%;
            height: 3px;
            background-color: rgba(255, 107, 53, 0.5);
            bottom: -3px;
            left: 0;
            filter: blur(2px);
        }

        .bucket-label {
            position: absolute;
            bottom: 30px;
            color: #FFA15A;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            font-size: 1rem;
            text-align: center;
            width: 100%;
            transition: all 0.3s ease;
        }

        .bucket:hover {
            transform: scale(1.05);
        }

        .bucket.edit-bucket:hover .bucket-label {
            color: #4DABF5;
            text-decoration: underline;
        }

        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .color-option {
            width: 25px;
            height: 25px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .color-option:hover {
            transform: scale(1.2);
            border-color: white;
        }

        .glow {
            animation: glow 0.5s ease-in-out;
        }

        @keyframes glow {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px #FF6B35); }
            100% { filter: brightness(1); }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        .pulse {
            animation: pulse 1.5s infinite ease-in-out;
        }

        /* Updated score popup animations for middle and surrounding buckets */
        @keyframes centerScorePopup {
            0% { transform: translateY(0) scale(1); opacity: 1; filter: drop-shadow(0 0 15px rgba(255, 107, 53, 0.9)); }
            50% { transform: translateY(-60px) scale(1.7); opacity: 0.8; filter: drop-shadow(0 0 20px rgba(255, 107, 53, 0.8)); }
            80% { transform: translateY(-80px) scale(2.2); opacity: 0.5; filter: drop-shadow(0 0 25px rgba(255, 107, 53, 0.7)); }
            100% { transform: translateY(-100px) scale(2.5); opacity: 0; filter: drop-shadow(0 0 30px rgba(255, 107, 53, 0.5)); }
        }

        @keyframes adjacentScorePopup {
            0% { transform: translateY(0) scale(1); opacity: 1; filter: drop-shadow(0 0 10px rgba(255, 107, 53, 0.8)); }
            50% { transform: translateY(-50px) scale(1.4); opacity: 0.7; filter: drop-shadow(0 0 15px rgba(255, 107, 53, 0.7)); }
            80% { transform: translateY(-70px) scale(1.7); opacity: 0.4; filter: drop-shadow(0 0 20px rgba(255, 107, 53, 0.6)); }
            100% { transform: translateY(-80px) scale(1.9); opacity: 0; filter: drop-shadow(0 0 25px rgba(255, 107, 53, 0.4)); }
        }

        @keyframes regularScorePopup {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            50% { transform: translateY(-25px) scale(1.1); opacity: 0.6; }
            100% { transform: translateY(-40px) scale(1.2); opacity: 0; }
        }

        .score-popup.center {
            animation: centerScorePopup 2s forwards;
            color: #FFD700;
            font-size: 1.8rem;
            z-index: 25;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }

        .score-popup.adjacent {
            animation: adjacentScorePopup 1.75s forwards;
            color: #FFA500;
            font-size: 1.6rem;
            z-index: 24;
            text-shadow: 0 0 8px rgba(255, 165, 0, 0.6);
        }

        .score-popup.regular {
            animation: regularScorePopup 1s forwards;
            font-size: 1.4rem;
        }

        /* Bucket hole glow effects */
        @keyframes bucketGlowCenter {
            0% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.7); }
            50% { box-shadow: 0 0 25px rgba(255, 215, 0, 0.9), 0 0 40px rgba(255, 107, 53, 0.6); }
            100% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.7); }
        }

        @keyframes bucketGlowAdjacent {
            0% { box-shadow: 0 0 8px rgba(255, 107, 53, 0.6); }
            50% { box-shadow: 0 0 20px rgba(255, 165, 0, 0.8), 0 0 30px rgba(255, 107, 53, 0.5); }
            100% { box-shadow: 0 0 8px rgba(255, 107, 53, 0.6); }
        }

        @keyframes bucketGlowRegular {
            0% { box-shadow: 0 0 5px rgba(255, 107, 53, 0.4); }
            50% { box-shadow: 0 0 10px rgba(255, 107, 53, 0.6); }
            100% { box-shadow: 0 0 5px rgba(255, 107, 53, 0.4); }
        }

        .bucket-hole.glow-center {
            animation: bucketGlowCenter 2s ease-in-out;
        }

        .bucket-hole.glow-adjacent {
            animation: bucketGlowAdjacent 1.75s ease-in-out;
        }

        .bucket-hole.glow-regular {
            animation: bucketGlowRegular 1s ease-in-out;
        }

        .bucket-edit-popup {
            position: absolute;
            top: -80px;
            left: 50%;
            transform: translateX(-50%);
            background-color: #2A1A15;
            border-radius: 10px;
            padding: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 5px;
            border: 2px solid #4A2F2A;
            width: 150px;
        }

        .bucket-edit-popup input {
            background-color: #3A2520;
            border: 1px solid #4A2F2A;
            border-radius: 5px;
            color: white;
            padding: 10px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 16px;
        }

        .bucket-edit-popup button {
            background-color: #FF6B35;
            border: none;
            border-radius: 5px;
            color: white;
            padding: 10px;
            cursor: pointer;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 16px;
            -webkit-tap-highlight-color: transparent;
        }

        .bucket-edit-popup button:hover {
            background-color: #FF8C5A;
        }

        .editor-help {
            color: #FF8C5A;
            margin-top: 10px;
            font-style: italic;
            text-align: center;
            font-size: 1rem;
        }

        .bottom-controls {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
            width: 100%;
            flex-wrap: wrap;
        }
        
        .sound-controls {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-label {
            color: #FFA15A;
            font-size: 1.1rem;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3A2520;
            border: 2px solid #4A2F2A;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 2px;
            background-color: #FF6B35;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #2A1A15;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        @keyframes ember {
            0% { opacity: 0.8; transform: translateY(0) scale(1); }
            50% { opacity: 0.6; transform: translateY(-15px) scale(0.8); }
            100% { opacity: 0; transform: translateY(-30px) scale(0.2); }
        }

        .ember-explosion {
            position: absolute;
            bottom: 20px;
            width: 60px;
            height: 60px;
            pointer-events: none;
            z-index: 15;
        }
        
        /* Sound visualization */
        .sound-wave {
            display: flex;
            align-items: center;
            height: 20px;
            gap: 3px;
        }
        
        .sound-bar {
            width: 3px;
            background-color: #FF6B35;
            border-radius: 3px;
            animation: soundWave 1s infinite ease-in-out alternate;
            animation-delay: calc(var(--i) * 0.1s);
        }
        
        @keyframes soundWave {
            0% { height: 5px; }
            100% { height: 20px; }
        }
        
        /* Game overlay for handling game over state */
        .game-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1 id="game-title">PLINKO BURN</h1>
    <div class="creator-credit">By Jozzuph</div>
    
    <div class="game-container">
        <div class="stats">
            <div class="score"><span id="score-label">$SHIRO Burned</span>: <span id="score-display">0</span></div>
            <div class="balls-left">Balls: <span id="balls-left-display">10</span></div>
        </div>
        
        <div class="drop-buttons">
            <button id="drop-btn" class="action-btn">Drop Ball</button>
            <button id="drop-5x-btn" class="action-btn">Drop 5x</button>
            <button id="drop-10x-btn" class="action-btn">Drop 10x</button>
            <button id="drop-50x-btn" class="action-btn">Drop 50x</button>
            <button id="drop-100x-btn" class="action-btn">Drop 100x</button>
        </div>
        
        <div id="canvas-container">
            <canvas id="plinko-canvas"></canvas>
            <canvas id="particles-canvas"></canvas>
            <div class="buckets" id="buckets-container"></div>
            <div class="game-overlay" id="game-overlay"></div>
        </div>
        
        <div class="bottom-controls">
            <button id="reset-btn" class="action-btn">Reset Game</button>
            <button id="edit-mode-btn" class="edit-mode">Edit Mode</button>
        </div>
        
        <div class="sound-controls">
            <div class="toggle-container">
                <span class="toggle-label">Sound FX</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="sound-toggle" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <div id="config-panel">
            <div class="editor-help">Tip: Click directly on bucket values to edit them when in Edit Mode!</div>
            <div class="config-grid">
                <div class="config-item">
                    <label for="rows-input">Rows of Pegs</label>
                    <input type="number" id="rows-input" min="5" max="15" value="8">
                </div>
                <div class="config-item">
                    <label for="columns-input">Columns of Pegs</label>
                    <input type="number" id="columns-input" min="5" max="20" value="11">
                </div>
                <div class="config-item">
                    <label for="buckets-input">Number of Buckets</label>
                    <input type="number" id="buckets-input" min="5" max="15" value="15">
                </div>
                <div class="config-item">
                    <label for="ball-size-input">Ball Size</label>
                    <input type="number" id="ball-size-input" min="5" max="15" value="10">
                </div>
                <div class="config-item">
                    <label for="restitution-input">Peg Bounciness</label>
                    <input type="number" id="restitution-input" min="0" max="1" step="0.1" value="0.5">
                </div>
                <div class="config-item">
                    <label for="gravity-input">Gravity</label>
                    <input type="number" id="gravity-input" min="0.1" max="2" step="0.1" value="1">
                </div>
                <div class="config-item">
                    <label for="balls-input">Starting Balls</label>
                    <input type="number" id="balls-input" min="1" value="10">
                </div>
                <div class="config-item">
                    <label for="score-label-input">Score Label</label>
                    <input type="text" id="score-label-input" value="$SHIRO Burned">
                </div>
                <div class="config-item">
                    <label for="game-title-input">Game Title</label>
                    <input type="text" id="game-title-input" value="PLINKO BURN">
                </div>
                <div class="config-item">
                    <label for="peg-color">Peg Color</label>
                    <div class="color-picker" id="peg-color-picker">
                        <div class="color-option" style="background-color: #FF6B35;" data-color="#FF6B35"></div>
                        <div class="color-option" style="background-color: #FFC15E;" data-color="#FFC15E"></div>
                        <div class="color-option" style="background-color: #FF8C5A;" data-color="#FF8C5A"></div>
                        <div class="color-option" style="background-color: #FF5151;" data-color="#FF5151"></div>
                        <div class="color-option" style="background-color: #FFD700;" data-color="#FFD700"></div>
                    </div>
                </div>
                <div class="config-item">
                    <label for="ball-color">Ball Color</label>
                    <div class="color-picker" id="ball-color-picker">
                        <div class="color-option" style="background-color: #FFEB3B;" data-color="#FFEB3B"></div>
                        <div class="color-option" style="background-color: #FFD54F;" data-color="#FFD54F"></div>
                        <div class="color-option" style="background-color: #FFCC80;" data-color="#FFCC80"></div>
                        <div class="color-option" style="background-color: #FFF59D;" data-color="#FFF59D"></div>
                        <div class="color-option" style="background-color: #FFF176;" data-color="#FFF176"></div>
                    </div>
                </div>
            </div>
            <button id="apply-btn" class="action-btn" style="margin-top: 15px;">Apply Changes</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.18.0/matter.min.js"></script>
    <script>
        // Game Configuration - keeping original dimensions
        const config = {
            rows: 18,
            columns: 12,
            buckets: 15,
            pegSize: 6,
            ballSize: 7,
            ballDensity: 0.3,
            restitution: 0.5,
            friction: 0.1,
            gravity: 1.3,
            startingBalls: 50,
            pegColor: '#FF6B35',
            ballColor: '#FFEB3B',
            bucketValues: [],
            scoreLabel: '$SHIRO Burned',
            gameTitle: 'PLINKO BURN',
            dropSpeed: 100, // ms between ball drops for multi-drop
            soundEnabled: true,
            particleIntensity: 1.0 // Multiplier for particle amount
        };

        // Game State
        let score = 0;
        let ballsLeft = config.startingBalls;
        let gameRunning = true;
        let editMode = false;
        let engine, render, world, canvas, particlesCanvas, particlesCtx;
        let pegs = [], walls = [], balls = [], bucketBodies = [];
        let dropInterval = null;
        let activePopup = null;
        let particles = [];
        let baseEmbers = [];
        let musicInterval = null;
        let musicOscillators = [];
        let isResetting = false; // Flag to prevent multiple resets
        
        // Audio Context and Sounds
        let audioContext;
        
        // DOM Elements
        const canvasContainer = document.getElementById('canvas-container');
        const scoreDisplay = document.getElementById('score-display');
        const scoreLabel = document.getElementById('score-label');
        const ballsLeftDisplay = document.getElementById('balls-left-display');
        const editModeBtn = document.getElementById('edit-mode-btn');
        const configPanel = document.getElementById('config-panel');
        const applyBtn = document.getElementById('apply-btn');
        const resetBtn = document.getElementById('reset-btn');
        const bucketsContainer = document.getElementById('buckets-container');
        const dropBtn = document.getElementById('drop-btn');
        const drop5xBtn = document.getElementById('drop-5x-btn');
        const drop10xBtn = document.getElementById('drop-10x-btn');
        const drop50xBtn = document.getElementById('drop-50x-btn');
        const drop100xBtn = document.getElementById('drop-100x-btn');
        const gameTitle = document.getElementById('game-title');
        const gameOverlay = document.getElementById('game-overlay');
        
        // Format large numbers with support for shorthand
        function formatNumber(num) {
            if (num >= 1e12) {
                return (num / 1e12).toFixed(1) + 'T';
            } else if (num >= 1e9) {
                return (num / 1e9).toFixed(1) + 'B';
            } else if (num >= 1e6) {
                return (num / 1e6).toFixed(1) + 'M';
            } else if (num >= 1e3) {
                return (num / 1e3).toFixed(1) + 'K';
            } else {
                return num.toString();
            }
        }

        // Parse shorthand numbers like "1T" to their numeric value
        function parseShorthandNumber(str) {
            str = str.trim().toUpperCase();
            
            // Regular number
            if (!isNaN(str)) {
                return parseFloat(str);
            }
            
            // Shorthand notation
            const value = parseFloat(str);
            if (isNaN(value)) return 0;
            
            const unit = str.replace(/[0-9.]/g, '').trim();
            
            switch (unit) {
                case 'K': return value * 1e3;
                case 'M': return value * 1e6;
                case 'B': return value * 1e9;
                case 'T': return value * 1e12;
                default: return value;
            }
        }

        function initGame() {
            // Initialize audio context
            initAudio();
            
            // Use fixed dimensions for consistency
            const fixedWidth = 800;
            const fixedHeight = 600;
            
            // Set up Matter.js
            engine = Matter.Engine.create({
                enableSleeping: true
            });
            world = engine.world;
            engine.gravity.y = config.gravity;
            
            canvas = document.getElementById('plinko-canvas');
            canvas.width = fixedWidth;
            canvas.height = fixedHeight;
            
            // Initialize particles canvas with fixed dimensions
            particlesCanvas = document.getElementById('particles-canvas');
            particlesCanvas.width = fixedWidth;
            particlesCanvas.height = fixedHeight;
            particlesCtx = particlesCanvas.getContext('2d');
            
            render = Matter.Render.create({
                canvas: canvas,
                engine: engine,
                options: {
                    width: fixedWidth,
                    height: fixedHeight,
                    wireframes: false,
                    background: 'transparent',
                    showSleeping: false,
                    showAngleIndicator: false
                }
            });
            
            Matter.Render.run(render);
            
            // Set initial values
            scoreLabel.textContent = config.scoreLabel;
            gameTitle.textContent = config.gameTitle;
            ballsLeftDisplay.textContent = ballsLeft;
            
            // Create physics world
            createBoundaries();
            createPegs();
            createBuckets();
            
            // Start the engine
            const runner = Matter.Runner.create({
                isFixed: true, 
                delta: 16  // target 60fps
            });
            Matter.Runner.run(runner, engine);
            
            // Event listeners
            Matter.Events.on(engine, 'collisionStart', handleCollision);
            // Only add resize listener once
            if (!window.resizeListenerAdded) {
                window.addEventListener('resize', handleResize);
                window.resizeListenerAdded = true;
            }
            
            // Input events
            setupInputHandlers();
            
            // Generate bucket values
            generateBucketValues();
            updateBucketDisplay();
            
            // Initialize base embers
            initBaseEmbers();
            
            // Start animation frame loop for particles
            requestAnimationFrame(updateParticles);
        }
        
        function initAudio() {
            try {
                // Only create AudioContext on user interaction to avoid autoplay issues
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            } catch (e) {
                console.warn('AudioContext not supported');
            }
        }
        
        function createBoundaries() {
            const wallOptions = { 
                isStatic: true,
                render: { 
                    fillStyle: '#3B2723',
                    strokeStyle: '#4A2F2A',
                    lineWidth: 1
                }
            };
            
            // Get current canvas dimensions to ensure proper alignment
            const currentWidth = canvas.width;
            
            // Clear any existing walls
            walls = [];
            
            // Left wall (positioned slightly off-screen)
            walls.push(Matter.Bodies.rectangle(
                -10, canvas.height / 2, 
                20, canvas.height,
                wallOptions
            ));
            
            // Right wall (ensuring proper alignment using current width)
            walls.push(Matter.Bodies.rectangle(
                currentWidth + 10, canvas.height / 2, 
                20, canvas.height,
                wallOptions
            ));
            
            // Add walls to world
            Matter.Composite.add(world, walls);
        }
        
        function createPegs() {
            const pegOptions = {
                isStatic: true,
                render: {
                    fillStyle: config.pegColor,
                    strokeStyle: '#FFF',
                    lineWidth: 1
                },
                restitution: config.restitution,
                friction: config.friction,
                chamfer: { radius: 2 }
            };
            
            // Clear existing pegs
            pegs = [];
            
            // Calculate spacing based on current canvas dimensions
            const spacing = canvas.width / (config.columns + 1);
            const verticalSpacing = (canvas.height - 180) / (config.rows + 1); // Reduced bottom margin
            const startY = 80; // Start lower to leave room at top
            
            for (let row = 0; row < config.rows; row++) {
                const offsetX = row % 2 === 0 ? 0 : spacing / 2;
                const numPegsInRow = row % 2 === 0 ? config.columns : config.columns - 1;
                
                for (let col = 0; col < numPegsInRow; col++) {
                    const pegX = offsetX + spacing * (col + 1);
                    const pegY = startY + verticalSpacing * (row + 1);
                    
                    // Only create pegs that are within the canvas boundaries
                    if (pegX > 0 && pegX < canvas.width && pegY > 0 && pegY < canvas.height - 100) {
                        const peg = Matter.Bodies.circle(
                            pegX,
                            pegY,
                            config.pegSize,
                            pegOptions
                        );
                        
                        // Give peg a reference to its original color
                        peg.originalColor = config.pegColor;
                        
                        pegs.push(peg);
                    }
                }
            }
            
            // Add pegs to world
            Matter.Composite.add(world, pegs);
        }
        
        function createBuckets() {
            const bucketWidth = canvas.width / config.buckets;
            const bucketHeight = 100;
            const bucketY = canvas.height - bucketHeight / 2;
            
            // Clear existing buckets
            bucketsContainer.innerHTML = '';
            bucketBodies = [];
            
            // Create bucket visuals and physics
            for (let i = 0; i < config.buckets; i++) {
                // Create bucket visual (now a hole)
                const bucket = document.createElement('div');
                bucket.className = 'bucket';
                bucket.dataset.index = i;
                
                // Create bucket hole visual
                const bucketHole = document.createElement('div');
                bucketHole.className = 'bucket-hole';
                
                // Create label for value
                const bucketLabel = document.createElement('div');
                bucketLabel.className = 'bucket-label';
                bucketLabel.textContent = formatNumber(config.bucketValues[i] || 0);
                
                bucket.appendChild(bucketHole);
                bucket.appendChild(bucketLabel);
                bucketsContainer.appendChild(bucket);
                
                // Create bucket walls (invisible for visual style)
                const leftWall = Matter.Bodies.rectangle(
                    i * bucketWidth, 
                    bucketY - 10,
                    5, 
                    bucketHeight - 20,
                    { 
                        isStatic: true,
                        render: { 
                            visible: false
                        },
                        chamfer: { radius: 2 }
                    }
                );
                
                // Only add right wall for the last bucket
                if (i === config.buckets - 1) {
                    const rightWall = Matter.Bodies.rectangle(
                        (i + 1) * bucketWidth, 
                        bucketY - 10, 
                        5, 
                        bucketHeight - 20,
                        { 
                            isStatic: true,
                            render: { 
                                visible: false
                            },
                            chamfer: { radius: 2 }
                        }
                    );
                    bucketBodies.push(rightWall);
                }
                
                // Create bucket bottom sensor for scoring
                const bucketSensor = Matter.Bodies.rectangle(
                    i * bucketWidth + bucketWidth / 2,
                    canvas.height - 5,
                    bucketWidth - 5,
                    10,
                    { 
                        isStatic: true,
                        isSensor: true,
                        render: { 
                            visible: false
                        },
                        bucketIndex: i
                    }
                );
                
                bucketBodies.push(leftWall, bucketSensor);
            }
            
            // Add buckets to world
            Matter.Composite.add(world, bucketBodies);
        }
        
        function dropBall() {
            if (ballsLeft <= 0 || !gameRunning) return;
            
            // Initialize audio context on first interaction
            if (!audioContext) {
                initAudio();
            }
            
            // Random position along the top
            const x = Math.random() * (canvas.width - 100) + 50;
            const y = 40;
            
            const ball = Matter.Bodies.circle(x, y, config.ballSize, {
                restitution: config.restitution,
                friction: config.friction,
                density: config.ballDensity,
                frictionAir: 0.02,
                render: {
                    fillStyle: config.ballColor,
                    strokeStyle: '#FFF',
                    lineWidth: 1
                }
            });
            
            Matter.Composite.add(world, ball);
            balls.push(ball);
            
            // Decrease balls left
            ballsLeft--;
            ballsLeftDisplay.textContent = ballsLeft;
            
            // Play sound
            playBallDropSound();
            
            // Check if game is over
            if (ballsLeft === 0 && balls.length === 0) {
                setTimeout(checkGameOver, 5000);
            }
        }
        
        function dropMultipleBalls(count) {
            // Initialize audio context on first interaction
            if (!audioContext) {
                initAudio();
            }
            
            const maxCount = Math.min(count, ballsLeft);
            if (maxCount <= 0) return;
            
            let dropped = 0;
            
            const dropNext = () => {
                if (dropped < maxCount && gameRunning) {
                    dropBall();
                    dropped++;
                    setTimeout(dropNext, config.dropSpeed);
                }
            };
            
            dropNext();
        }
        
        function startContinuousDrop() {
            // Initialize audio context on first interaction
            if (!audioContext) {
                initAudio();
            }
            
            if (dropInterval) return;
            
            dropBall(); // Drop first ball immediately
            
            dropInterval = setInterval(() => {
                if (ballsLeft > 0 && gameRunning) {
                    dropBall();
                } else {
                    stopContinuousDrop();
                }
            }, 200); // Drop a ball every 200ms
        }
        
        function stopContinuousDrop() {
            if (dropInterval) {
                clearInterval(dropInterval);
                dropInterval = null;
            }
        }
        
        function generateBucketValues() {
            // If bucket values already exist with matching length, don't regenerate
            if (config.bucketValues.length === config.buckets) {
                return;
            }
            
            // Reset to empty array
            config.bucketValues = [];
            
            // Set middle bucket to 50B
            const middleIndex = Math.floor((config.buckets - 1) / 2);
            const middleValue = 50 * 1e9; // 50B
            
            // Generate symmetrical values
            for (let i = 0; i < config.buckets; i++) {
                const distFromCenter = Math.abs(i - middleIndex);
                
                if (distFromCenter === 0) {
                    // Center bucket
                    config.bucketValues[i] = middleValue;
                } else {
                    // Calculate decreasing values outward (exponential decay)
                    const ratio = Math.pow(0.7, distFromCenter);
                    const value = Math.round(middleValue * ratio);
                    config.bucketValues[i] = value;
                }
            }
        }
        
        function updateBucketDisplay() {
            const buckets = document.querySelectorAll('.bucket');
            
            buckets.forEach((bucket, index) => {
                const label = bucket.querySelector('.bucket-label');
                if (label) {
                    label.textContent = formatNumber(config.bucketValues[index] || 0);
                }
                
                // Add or remove edit-bucket class based on edit mode
                if (editMode) {
                    bucket.classList.add('edit-bucket');
                } else {
                    bucket.classList.remove('edit-bucket');
                }
            });
        }
        
        function showBucketEditPopup(bucket) {
            // If another popup is open, close it
            if (activePopup) {
                activePopup.remove();
                activePopup = null;
            }
            
            const bucketIndex = parseInt(bucket.dataset.index);
            const currentValue = config.bucketValues[bucketIndex];
            
            const popup = document.createElement('div');
            popup.className = 'bucket-edit-popup';
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = formatNumber(currentValue);
            
            input.addEventListener('keydown', e => {
                if (e.key === 'Enter') {
                    saveBucketValue();
                }
            });
            
            const saveBtn = document.createElement('button');
            saveBtn.textContent = 'Save';
            saveBtn.addEventListener('click', saveBucketValue);
            
            popup.appendChild(input);
            popup.appendChild(saveBtn);
            bucket.appendChild(popup);
            
            // Set as active popup
            activePopup = popup;
            
            // Focus input (with slight delay to allow tap events to complete)
            setTimeout(() => {
                input.focus();
                input.select();
            }, 50);
            
            function saveBucketValue() {
                const newValue = parseShorthandNumber(input.value);
                config.bucketValues[bucketIndex] = newValue;
                updateBucketDisplay();
                popup.remove();
                activePopup = null;
            }
            
            // Close when clicking/tapping outside - with a small delay to avoid immediate closing
            setTimeout(() => {
                const closeHandler = e => {
                    // Only close if the click/tap is outside the popup and not on the bucket
                    if (!popup.contains(e.target) && !bucket.contains(e.target) || bucket === e.target) {
                        popup.remove();
                        activePopup = null;
                        document.removeEventListener('click', closeHandler);
                        document.removeEventListener('touchend', closeHandler);
                    }
                };
                
                document.addEventListener('click', closeHandler);
                document.addEventListener('touchend', closeHandler);
            }, 100);
        }
        
        function handleCollision(event) {
            const pairs = event.pairs;
            
            for (let i = 0; i < pairs.length; i++) {
                const pair = pairs[i];
                
                // Check if a ball hit a peg
                if (pegs.includes(pair.bodyA) || pegs.includes(pair.bodyB)) {
                    const peg = pegs.includes(pair.bodyA) ? pair.bodyA : pair.bodyB;
                    const ball = pegs.includes(pair.bodyA) ? pair.bodyB : pair.bodyA;
                    
                    // Skip if the peg is already flashing
                    if (peg.isFlashing) continue;
                    
                    // Mark peg as flashing to prevent multiple triggers
                    peg.isFlashing = true;
                    
                    // Visual feedback
                    const originalFill = peg.originalColor;
                    peg.render.fillStyle = '#FFFFFF';
                    
                    // Get collision velocity for sound pitch
                    const velocity = Math.sqrt(
                        Math.pow(ball.velocity.x, 2) + 
                        Math.pow(ball.velocity.y, 2)
                    );
                    
                    // Play sound based on velocity
                    playPegHitSound(200 + velocity * 100);
                    
                    // Reset color after a short delay
                    setTimeout(() => {
                        peg.render.fillStyle = originalFill;
                        peg.isFlashing = false;
                    }, 100);
                }
                
                // Check if a ball hit a bucket sensor
                if ((pair.bodyA.isSensor || pair.bodyB.isSensor) && 
                    (balls.includes(pair.bodyA) || balls.includes(pair.bodyB))) {
                    
                    const sensor = pair.bodyA.isSensor ? pair.bodyA : pair.bodyB;
                    const ball = pair.bodyA.isSensor ? pair.bodyB : pair.bodyA;
                    
                    if (sensor.bucketIndex !== undefined && balls.includes(ball)) {
                        scorePoints(sensor.bucketIndex, ball);
                        
                        // Remove ball from tracking array
                        const ballIndex = balls.indexOf(ball);
                        if (ballIndex !== -1) {
                            balls.splice(ballIndex, 1);
                        }
                        
                        // Remove ball from world after a delay
                        setTimeout(() => {
                            Matter.Composite.remove(world, ball);
                            
                            // Check if game is over
                            if (ballsLeft === 0 && balls.length === 0) {
                                setTimeout(checkGameOver, 2000);
                            }
                        }, 100);
                    }
                }
            }
        }
        
        function scorePoints(bucketIndex, ball) {
            const points = config.bucketValues[bucketIndex];
            score += points;
            scoreDisplay.textContent = formatNumber(score);
            
            // Calculate middle bucket and adjacent buckets
            const middleIndex = Math.floor((config.buckets - 1) / 2);
            const isMiddle = bucketIndex === middleIndex;
            const isAdjacent = Math.abs(bucketIndex - middleIndex) === 1;
            
            // Show visual feedback on bucket
            const bucket = document.querySelector(`.bucket[data-index="${bucketIndex}"]`);
            if (bucket) {
                bucket.classList.add('glow');
                setTimeout(() => {
                    bucket.classList.remove('glow');
                }, 500);
                
                // Add glow effect to bucket hole
                const bucketHole = bucket.querySelector('.bucket-hole');
                if (bucketHole) {
                    // Apply appropriate glow class
                    if (isMiddle) {
                        bucketHole.classList.add('glow-center');
                        setTimeout(() => bucketHole.classList.remove('glow-center'), 2000);
                    } else if (isAdjacent) {
                        bucketHole.classList.add('glow-adjacent');
                        setTimeout(() => bucketHole.classList.remove('glow-adjacent'), 1750);
                    } else {
                        bucketHole.classList.add('glow-regular');
                        setTimeout(() => bucketHole.classList.remove('glow-regular'), 1000);
                    }
                }
            }
            
            // Create score popup
            const popup = document.createElement('div');
            popup.className = 'score-popup';
            
            // Add appropriate class based on position
            if (isMiddle) {
                popup.classList.add('center');
            } else if (isAdjacent) {
                popup.classList.add('adjacent');
            } else {
                popup.classList.add('regular');
            }
            
            popup.textContent = `+${formatNumber(points)}`;
            
            // Position the popup directly above the bucket
            // Using percentage-based positioning for better mobile compatibility
            const bucketWidth = 100 / config.buckets;
            const leftPosition = bucketWidth * (bucketIndex + 0.5);
            
            popup.style.position = 'absolute';
            popup.style.zIndex = '50';
            popup.style.left = `${leftPosition}%`;
            popup.style.transform = 'translateX(-50%)';
            popup.style.bottom = '80px';
            
            // Add popup to the container
            canvasContainer.appendChild(popup);
            
            // Set duration based on position (already handled by CSS animations)
            // But we need to remove the element after animation completes
            const duration = isMiddle ? 2000 : isAdjacent ? 1750 : 1000;
            
            setTimeout(() => {
                if (popup && popup.parentNode) {
                    popup.remove();
                }
            }, duration);
            
            // Play sound
            playBucketSound(bucketIndex);
            
            // Create ember explosion effect
            createEmberExplosion(bucketIndex);
        }
        
        function playBallDropSound() {
            if (!audioContext || !config.soundEnabled) return;
            const frequency = 400 + Math.random() * 100;
            playSound(frequency, 0.03, 'sine', 0.1);
        }
        
        function playPegHitSound(frequency) {
            if (!audioContext || !config.soundEnabled) return;
            playSound(frequency, 0.05, 'triangle', 0.08);
        }
        
        function playBucketSound(bucketIndex) {
            if (!audioContext || !config.soundEnabled) return;
            
            // Calculate how far from center the bucket is
            const middleIndex = Math.floor((config.buckets - 1) / 2);
            const distFromCenter = Math.abs(bucketIndex - middleIndex);
            const isMiddle = distFromCenter === 0;
            const isAdjacent = distFromCenter === 1;
            
            // Sound intensity based on position
            let volume = 0.1;
            let intensity = 1;
            
            if (isMiddle) {
                // Center bucket - most intense sound
                volume = 0.3;
                intensity = 2;
            } else if (isAdjacent) {
                // Adjacent buckets - enhanced sound
                volume = 0.2;
                intensity = 1.5;
            }
            
            // Base frequency depends on position (lower/deeper sounds for center)
            const baseFreq = isMiddle ? 80 : isAdjacent ? 120 : 180;
            
            // Play sizzle sound with varying intensity
            playSizzleSound(baseFreq, volume, intensity);
        }
        
        function playSound(frequency, volume, type = 'sine', duration = 0.3) {
            if (!audioContext || !config.soundEnabled) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                gainNode.gain.value = volume;
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
                
                setTimeout(() => {
                    oscillator.stop();
                }, duration * 1000);
            } catch (e) {
                console.warn('Error playing sound', e);
            }
        }
        
        function playSizzleSound(baseFreq, volume, intensity = 1) {
            if (!audioContext || !config.soundEnabled) return;
            
            try {
                // Create noise
                const bufferSize = 2 * audioContext.sampleRate;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                // Create filter for sizzle effect
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 1;
                
                // More intense filter for center buckets
                if (intensity > 1.3) {
                    // Add a second filter for more character
                    const filter2 = audioContext.createBiquadFilter();
                    filter2.type = 'lowpass';
                    filter2.frequency.value = baseFreq * 2;
                    
                    // Add distortion for intense center bucket sounds
                    const distortion = audioContext.createWaveShaper();
                    distortion.curve = makeDistortionCurve(intensity * 50);
                    
                    // Create gain for volume control
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = volume;
                    
                    // Connect nodes with distortion for intense sounds
                    noise.connect(filter);
                    filter.connect(filter2);
                    filter2.connect(distortion);
                    distortion.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // More complex envelope for intense sounds
                    const now = audioContext.currentTime;
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume, now + 0.05);
                    gainNode.gain.setValueAtTime(volume, now + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.8, now + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, now + 0.7);
                    
                    // Start noise
                    noise.start();
                    
                    // Stop after duration
                    setTimeout(() => {
                        noise.stop();
                    }, 700);
                } else {
                    // Create gain for volume control
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = volume;
                    
                    // Connect nodes
                    noise.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Start noise and ramp down volume
                    noise.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.6);
                    
                    // Stop after duration
                    setTimeout(() => {
                        noise.stop();
                    }, 600);
                }
            } catch (e) {
                console.warn('Error playing sizzle sound', e);
            }
        }
        
        // Creates a distortion curve for sound effects
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            
            return curve;
        }
        
        function checkGameOver() {
            if (ballsLeft === 0 && balls.length === 0) {
                gameRunning = false;
                
                // Get score container
                const scoreContainer = document.querySelector('.score');
                
                // Add game-over class to score for animation
                scoreContainer.classList.add('game-over');
                
                // Show overlay
                if (gameOverlay) {
                    gameOverlay.style.display = 'flex';
                }
                
                // Play a final sound
                if (config.soundEnabled) {
                    playSizzleSound(150, 0.2, 2);
                }
                
                // Create falling embers for end game effect
                for (let i = 0; i < 50; i++) {
                    setTimeout(() => {
                        const randomBucket = Math.floor(Math.random() * config.buckets);
                        createEmberExplosion(randomBucket);
                    }, i * 200);
                }
            }
        }
        
        function resetGame() {
            // Prevent multiple reset calls
            if (isResetting) return;
            isResetting = true;
            
            // Reset game state
            score = 0;
            ballsLeft = config.startingBalls;
            gameRunning = true;
            
            // Update displays
            scoreDisplay.textContent = '0';
            ballsLeftDisplay.textContent = ballsLeft;
            
            // Remove game-over state
            const scoreContainer = document.querySelector('.score');
            scoreContainer.classList.remove('game-over');
            
            // Hide overlay
            if (gameOverlay) {
                gameOverlay.style.display = 'none';
            }
            
            // Close any open popups
            if (activePopup) {
                activePopup.remove();
                activePopup = null;
            }
            
            // Stop any continuous dropping
            stopContinuousDrop();
            
            // Store original canvas dimensions
            const originalWidth = canvas.width;
            const originalHeight = canvas.height;
            
            // Save the engine's gravity
            const originalGravity = engine.gravity.y;
            
            // Completely destroy the old engine and create a new one
            Matter.Engine.clear(engine);
            Matter.Render.stop(render);
            Matter.Runner.stop(engine);
            
            // Create a fresh engine
            engine = Matter.Engine.create({
                enableSleeping: true
            });
            world = engine.world;
            engine.gravity.y = originalGravity;
            
            // Reset arrays
            pegs = [];
            walls = [];
            balls = [];
            bucketBodies = [];
            
            // Reset and restart the renderer with exact same dimensions
            render.engine = engine;
            render.options.width = originalWidth;
            render.options.height = originalHeight;
            render.canvas.width = originalWidth;
            render.canvas.height = originalHeight;
            Matter.Render.run(render);
            
            // Start a new runner
            const runner = Matter.Runner.create({
                isFixed: true, 
                delta: 16
            });
            Matter.Runner.run(runner, engine);
            
            // Reconnect collision handler
            Matter.Events.on(engine, 'collisionStart', handleCollision);
            
            // Rebuild the game elements with a slight delay
            setTimeout(() => {
                createBoundaries();
                createPegs();
                createBuckets();
                
                // Update bucket display
                updateBucketDisplay();
                
                // Reset particles
                particles = [];
                initBaseEmbers();
                
                // Allow reset again
                isResetting = false;
            }, 100);
        }
        
        function setupInputHandlers() {
            // Edit mode toggle
            editModeBtn.addEventListener('click', (e) => {
                e.preventDefault();
                editMode = !editMode;
                configPanel.style.display = editMode ? 'block' : 'none';
                editModeBtn.classList.toggle('active', editMode);
                editModeBtn.textContent = editMode ? 'Close Editor' : 'Edit Mode';
                
                // Update bucket display to show which are editable
                updateBucketDisplay();
            });
            
            // Apply configuration changes
            applyBtn.addEventListener('click', (e) => {
                e.preventDefault();
                applyConfigChanges();
            });
            
            // Reset game button
            resetBtn.addEventListener('click', (e) => {
                e.preventDefault();
                resetGame();
            });
            
            // Drop button - for both mouse and touch events
            const handleDropStart = (e) => {
                e.preventDefault();
                if (audioContext) {
                    // Resume audio context if suspended (needed for mobile)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } else {
                    initAudio();
                }
                startContinuousDrop();
            };
            
            const handleDropEnd = (e) => {
                if (e) e.preventDefault();
                stopContinuousDrop();
            };
            
            // Mouse events
            dropBtn.addEventListener('mousedown', handleDropStart);
            dropBtn.addEventListener('mouseup', handleDropEnd);
            dropBtn.addEventListener('mouseleave', handleDropEnd);
            
            // Touch events
            dropBtn.addEventListener('touchstart', handleDropStart, { passive: false });
            dropBtn.addEventListener('touchend', handleDropEnd, { passive: false });
            dropBtn.addEventListener('touchcancel', handleDropEnd, { passive: false });
            
            // Multiple drop buttons with proper touch handling
            const setupDropButton = (btn, amount) => {
                const dropHandler = (e) => {
                    e.preventDefault();
                    // Resume audio context if needed
                    if (audioContext && audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                    dropMultipleBalls(amount);
                };
                
                btn.addEventListener('click', dropHandler);
                btn.addEventListener('touchend', dropHandler, { passive: false });
            };
            
            setupDropButton(drop5xBtn, 5);
            setupDropButton(drop10xBtn, 10);
            setupDropButton(drop50xBtn, 50);
            setupDropButton(drop100xBtn, 100);
            
            // Bucket click/touch handlers for editing values
            const bucketClickHandler = (e) => {
                const bucket = e.target.closest('.bucket');
                if (bucket && editMode && bucket.classList.contains('edit-bucket')) {
                    e.preventDefault();
                    e.stopPropagation();
                    showBucketEditPopup(bucket);
                }
            };
            
            document.addEventListener('click', bucketClickHandler);
            document.addEventListener('touchend', bucketClickHandler, { passive: false });
            
            // Sound toggle
            const soundToggle = document.getElementById('sound-toggle');
            if (soundToggle) {
                soundToggle.addEventListener('change', () => {
                    config.soundEnabled = soundToggle.checked;
                });
            }
            
            // Game overlay click for reset after game over
            if (gameOverlay) {
                const gameOverHandler = (e) => {
                    e.preventDefault();
                    if (!gameRunning) {
                        resetGame();
                    }
                };
                
                gameOverlay.addEventListener('click', gameOverHandler);
                gameOverlay.addEventListener('touchend', gameOverHandler, { passive: false });
            }
            
            // Color pickers
            setupColorPickers();
        }
        
        function setupColorPickers() {
            const pegColorOptions = document.querySelectorAll('#peg-color-picker .color-option');
            pegColorOptions.forEach(option => {
                const colorSelectHandler = (e) => {
                    e.preventDefault();
                    const color = option.dataset.color;
                    config.pegColor = color;
                    
                    // Update all pegs
                    pegs.forEach(peg => {
                        peg.render.fillStyle = color;
                        peg.originalColor = color;
                    });
                    
                    // Visual feedback
                    pegColorOptions.forEach(o => o.style.border = '2px solid rgba(255, 255, 255, 0.2)');
                    option.style.border = '2px solid white';
                };
                
                option.addEventListener('click', colorSelectHandler);
                option.addEventListener('touchend', colorSelectHandler, { passive: false });
                
                // Set initial selection
                if (option.dataset.color === config.pegColor) {
                    option.style.border = '2px solid white';
                }
            });
            
            const ballColorOptions = document.querySelectorAll('#ball-color-picker .color-option');
            ballColorOptions.forEach(option => {
                const colorSelectHandler = (e) => {
                    e.preventDefault();
                    config.ballColor = option.dataset.color;
                    
                    // Visual feedback
                    ballColorOptions.forEach(o => o.style.border = '2px solid rgba(255, 255, 255, 0.2)');
                    option.style.border = '2px solid white';
                };
                
                option.addEventListener('click', colorSelectHandler);
                option.addEventListener('touchend', colorSelectHandler, { passive: false });
                
                // Set initial selection
                if (option.dataset.color === config.ballColor) {
                    option.style.border = '2px solid white';
                }
            });
        }
        
        function applyConfigChanges() {
            // Save old values
            const oldRows = config.rows;
            const oldColumns = config.columns;
            const oldBuckets = config.buckets;
            
            // Get values from inputs
            config.rows = parseInt(document.getElementById('rows-input').value);
            config.columns = parseInt(document.getElementById('columns-input').value);
            config.buckets = parseInt(document.getElementById('buckets-input').value);
            config.ballSize = parseInt(document.getElementById('ball-size-input').value);
            config.restitution = parseFloat(document.getElementById('restitution-input').value);
            config.gravity = parseFloat(document.getElementById('gravity-input').value);
            config.startingBalls = parseInt(document.getElementById('balls-input').value);
            config.scoreLabel = document.getElementById('score-label-input').value;
            config.gameTitle = document.getElementById('game-title-input').value;
            
            // Update displays
            scoreLabel.textContent = config.scoreLabel;
            gameTitle.textContent = config.gameTitle;
            
            // Set balls left to new value
            ballsLeft = config.startingBalls;
            ballsLeftDisplay.textContent = ballsLeft;
            
            // Update gravity
            engine.gravity.y = config.gravity;
            
            // If the layout has changed, rebuild the board
            if (oldRows !== config.rows || oldColumns !== config.columns || oldBuckets !== config.buckets) {
                // Generate new bucket values if there's a bucket count change
                if (oldBuckets !== config.buckets) {
                    config.bucketValues = []; // Clear values to force regeneration
                    generateBucketValues();
                }
                resetGame();
            } else {
                updateBucketDisplay();
            }
            
            // Close config panel
            editMode = false;
            configPanel.style.display = 'none';
            editModeBtn.classList.remove('active');
            editModeBtn.textContent = 'Edit Mode';
            updateBucketDisplay();
        }
        
        function handleResize() {
            // Store current game state to restore after resize
            const currentScore = score;
            const currentBallsLeft = ballsLeft;
            
            // Only update dimensions, don't change the game properties
            canvas.width = canvasContainer.offsetWidth;
            canvas.height = canvasContainer.offsetHeight;
            
            particlesCanvas.width = canvasContainer.offsetWidth;
            particlesCanvas.height = canvasContainer.offsetHeight;
            
            // Properly clean up the old engine
            Matter.Engine.clear(engine);
            Matter.Render.stop(render);
            
            // Set up new engine with same settings
            engine = Matter.Engine.create({
                enableSleeping: true
            });
            world = engine.world;
            engine.gravity.y = config.gravity;
            
            // Update render with new engine and exact dimensions
            render.engine = engine;
            render.options.width = canvas.width;
            render.options.height = canvas.height;
            render.canvas.width = canvas.width;
            render.canvas.height = canvas.height;
            
            // Set proper pixel ratio
            Matter.Render.setPixelRatio(render, window.devicePixelRatio);
            
            // Restart the renderer
            Matter.Render.run(render);
            
            // Start a new runner
            const runner = Matter.Runner.create({
                isFixed: true,
                delta: 16
            });
            Matter.Runner.run(runner, engine);
            
            // Reconnect collision handler
            Matter.Events.on(engine, 'collisionStart', handleCollision);
            
            // Reset arrays
            pegs = [];
            walls = [];
            balls = [];
            bucketBodies = [];
            
            // Rebuild the game elements
            createBoundaries();
            createPegs();
            createBuckets();
            
            // Restore game state
            score = currentScore;
            ballsLeft = currentBallsLeft;
            scoreDisplay.textContent = formatNumber(score);
            ballsLeftDisplay.textContent = ballsLeft;
            
            // Reset particles
            particles = [];
            initBaseEmbers();
        }
        
        // Initialize base embers
        function initBaseEmbers() {
            baseEmbers = [];
            const numEmbers = 15;
            
            for (let i = 0; i < numEmbers; i++) {
                baseEmbers.push({
                    x: Math.random() * canvas.width,
                    y: canvas.height - Math.random() * 30,
                    radius: 2 + Math.random() * 3,
                    color: getEmberColor(Math.random()),
                    velocity: { x: (Math.random() - 0.5) * 0.5, y: -0.5 - Math.random() * 1.5 },
                    life: 0,
                    maxLife: 100 + Math.random() * 100
                });
            }
        }
        
        function getEmberColor(t) {
            // Colors from orange-yellow to red
            const colors = [
                { r: 255, g: 107, b: 53 },  // Orange
                { r: 255, g: 140, b: 85 },  // Light orange
                { r: 255, g: 69, b: 0 },    // Red-orange
                { r: 255, g: 177, b: 31 }   // Yellow-orange
            ];
            
            const index = Math.floor(t * colors.length);
            const color = colors[Math.min(index, colors.length - 1)];
            
            return `rgba(${color.r}, ${color.g}, ${color.b}, ${0.7 + Math.random() * 0.3})`;
        }
        
        function createEmberExplosion(bucketIndex) {
            const bucketWidth = canvas.width / config.buckets;
            const x = bucketIndex * bucketWidth + bucketWidth / 2;
            const y = canvas.height - 30;
            
            // Calculate middle bucket index
            const middleIndex = Math.floor((config.buckets - 1) / 2);
            const isMiddle = bucketIndex === middleIndex;
            const isAdjacent = Math.abs(bucketIndex - middleIndex) === 1;
            
            // Number of particles based on bucket position
            let numParticles = 10; // Default for regular buckets
            
            if (isMiddle) {
                numParticles = 40; // Many particles for middle
            } else if (isAdjacent) {
                numParticles = 25; // More particles for adjacent
            }
            
            // Apply particle intensity multiplier
            numParticles = Math.round(numParticles * config.particleIntensity);
            
            // Create particles
            for (let i = 0; i < numParticles; i++) {
                // Most particles go up, fewer to the sides
                const angle = (Math.random() * Math.PI * 1.5) - (Math.PI * 0.75);
                
                // Higher initial velocity for center/adjacent buckets
                const speed = isMiddle ? 3 + Math.random() * 2 : 
                             isAdjacent ? 2 + Math.random() * 2 : 
                             1 + Math.random() * 2;
                
                particles.push({
                    x,
                    y,
                    radius: 2 + Math.random() * 3,
                    color: getEmberColor(Math.random()),
                    velocity: {
                        x: Math.cos(angle) * speed,
                        // Upward initial velocity, will be affected by gravity
                        y: Math.sin(angle) * speed - (isMiddle ? 3 : isAdjacent ? 2 : 1)
                    },
                    gravity: 0.15 + Math.random() * 0.1, // Stronger gravity for faster fall
                    life: 0,
                    // Longer max life for middle bucket particles
                    maxLife: isMiddle ? 40 + Math.random() * 40 : 
                             isAdjacent ? 30 + Math.random() * 30 : 
                             20 + Math.random() * 20,
                    alphaFade: 0.03 + Math.random() * 0.05
                });
            }
        }
        
        function updateParticles() {
            // Clear canvas
            particlesCtx.clearRect(0, 0, particlesCanvas.width, particlesCanvas.height);
            
            // Update and draw base embers
            for (let i = 0; i < baseEmbers.length; i++) {
                const ember = baseEmbers[i];
                
                ember.x += ember.velocity.x;
                ember.y += ember.velocity.y;
                ember.life++;
                
                // If ember is dead, reset it at the bottom
                if (ember.life >= ember.maxLife) {
                    ember.x = Math.random() * canvas.width;
                    ember.y = canvas.height - Math.random() * 10;
                    ember.velocity.y = -0.5 - Math.random() * 1.5;
                    ember.life = 0;
                    ember.maxLife = 100 + Math.random() * 100;
                }
                
                // Calculate alpha based on life
                const alpha = 1 - ember.life / ember.maxLife;
                
                // Draw ember
                particlesCtx.beginPath();
                particlesCtx.arc(ember.x, ember.y, ember.radius, 0, Math.PI * 2);
                particlesCtx.fillStyle = ember.color.replace(/[\d\.]+\)$/g, `${alpha})`);
                particlesCtx.fill();
            }
            
            // Update and draw explosion particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                
                p.x += p.velocity.x;
                p.y += p.velocity.y;
                p.velocity.y += p.gravity || 0.15; // Stronger gravity for faster fall
                p.life++;
                
                // Remove dead particles
                if (p.life >= p.maxLife) {
                    particles.splice(i, 1);
                    continue;
                }
                
                // Calculate alpha based on life
                const alpha = 1 - p.life / p.maxLife;
                
                // Draw particle
                particlesCtx.beginPath();
                particlesCtx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                particlesCtx.fillStyle = p.color.replace(/[\d\.]+\)$/g, `${alpha})`);
                particlesCtx.fill();
            }
            
            // Continue animation loop
            requestAnimationFrame(updateParticles);
        }
        
        // Prevent scrolling when touching the game container and canvas on mobile
        function preventScrolling() {
            const preventDefault = e => {
                e.preventDefault();
            };
            
            document.querySelector('.game-container').addEventListener('touchmove', preventDefault, { passive: false });
            document.getElementById('plinko-canvas').addEventListener('touchmove', preventDefault, { passive: false });
            document.getElementById('particles-canvas').addEventListener('touchmove', preventDefault, { passive: false });
            
            // Also prevent double-tap zoom
            document.addEventListener('touchend', e => {
                const now = Date.now();
                const lastTouch = document.lastTouch || now - 1000;
                const delta = now - lastTouch;
                if (delta < 300) {
                    e.preventDefault();
                }
                document.lastTouch = now;
            }, { passive: false });
        }
        
        // Initialize game when window is loaded
        window.addEventListener('load', () => {
            // Set fixed dimensions for the game container to ensure consistent physics
            const gameContainer = document.querySelector('.game-container');
            const canvasContainer = document.getElementById('canvas-container');
            
            // Make sure canvas dimensions are consistent
            if (canvas) {
                canvas.width = 800; // Match the container width in CSS
                canvas.height = 600;
            }
            
            if (particlesCanvas) {
                particlesCanvas.width = 800;
                particlesCanvas.height = 600;
            }
            
            // Initialize game
            initGame();
            
            // Update input min/max values based on config
            document.getElementById('rows-input').min = 5;
            document.getElementById('rows-input').max = 20;
            document.getElementById('rows-input').value = config.rows;
            
            document.getElementById('columns-input').min = 5;
            document.getElementById('columns-input').max = 20;
            document.getElementById('columns-input').value = config.columns;
            
            document.getElementById('buckets-input').min = 5;
            document.getElementById('buckets-input').max = 15;
            document.getElementById('buckets-input').value = config.buckets;
            
            // Prevent scrolling on touch devices
            preventScrolling();
            
            // For mobile, add a click/touch handler to initialize audio on first interaction
            document.body.addEventListener('click', function initAudioOnFirstInteraction() {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                } else if (!audioContext) {
                    initAudio();
                }
                document.body.removeEventListener('click', initAudioOnFirstInteraction);
            }, { once: true });
        });
    </script>
</body>
</html>

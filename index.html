<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plinko Burn</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            background-color: #2C1B18;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            background-image: linear-gradient(to bottom, #3B1D15, #2C1B18);
        }

        .title-container {
            width: 100%;
            max-width: 800px;
            margin-bottom: 10px;
            text-align: center;
        }

        .title-container h1 {
            font-size: 2.5rem;
            color: #FF6B35;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.8), 3px 3px 0px #7A1C00;
            transform: rotate(-1deg);
        }

        .creator-credit {
            font-size: 1rem;
            color: #FFA15A;
            text-align: center;
            margin-bottom: 10px;
            font-style: italic;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
        }

        /* Enhanced score container styling */
        .score-container {
            width: 100%;
            max-width: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 1.3rem;
            background-color: #3B2723;
            padding: 12px 15px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 107, 53, 0.3);
            border: 2px solid #FF6B35;
            position: relative;
            overflow: hidden;
        }

        .score-container::before {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #FF6B35, #FFC107, #FF6B35);
            animation: burnGlow 2s infinite;
            box-shadow: 0 0 10px 2px rgba(255, 107, 53, 0.7);
        }

        @keyframes burnGlow {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        #score-prefix {
            font-weight: bold;
            color: #FFA15A;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            font-size: 1.4rem;
        }

        #score-value {
            font-weight: bold;
            font-size: 1.6rem;
            color: #FFC107;
            text-shadow: 0 0 10px rgba(255, 193, 7, 0.8), 0 0 5px rgba(255, 107, 53, 0.5);
            animation: scorePulse 2s infinite;
        }

        @keyframes scorePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .ball-counter {
            font-size: 1rem;
            color: #FFA15A;
            margin-left: auto;
            background-color: #2A1A15;
            padding: 4px 8px;
            border-radius: 6px;
            border: 1px solid #FF8C5A;
        }

        .game-container {
            width: 100%;
            max-width: 800px;
            background-color: #3B2723;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(255, 107, 53, 0.2);
            position: relative;
            border: 3px solid #4A2F2A;
            transition: transform 0.3s;
        }

        .game-container:hover {
            transform: scale(1.01);
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
        }

        .game-header {
            padding: 15px;
            background: linear-gradient(to right, #3B2723, #4A2F2A);
            text-align: center;
        }

        .multiplier-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .multiplier-btn {
            padding: 10px 15px;
            background-color: #FF6B35;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-weight: bold;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0px 3px 0px #7A1C00, 0px 4px 6px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
        }

        .multiplier-btn:hover {
            background-color: #FF8C5A;
            transform: translateY(-2px);
            box-shadow: 0px 5px 0px #7A1C00, 0px 7px 10px rgba(0, 0, 0, 0.3);
        }

        .multiplier-btn:active {
            transform: translateY(1px);
            box-shadow: 0px 2px 0px #7A1C00, 0px 3px 4px rgba(0, 0, 0, 0.3);
        }

        .multiplier-btn.active {
            background-color: #FF8C5A;
            box-shadow: 0px 3px 0px #7A1C00, 0px 6px 10px rgba(255, 107, 53, 0.4);
        }

        /* Styling for low-ball multiplier buttons - still clickable but visually different */
        .multiplier-btn.low-balls {
            background-color: #FF6B35;
            opacity: 0.8;
            box-shadow: 0px 3px 0px #7A1C00, 0px 4px 6px rgba(0, 0, 0, 0.3);
        }

        .multiplier-btn.low-balls:hover {
            background-color: #FF8C5A;
            opacity: 0.9;
        }

        canvas {
            width: 100%;
            background-color: #241914;
            display: block;
        }

        .game-footer {
            padding: 15px;
            text-align: center;
            background: linear-gradient(to right, #3B2723, #4A2F2A);
        }

        /* Modified config-panel to display below the game */
        .config-panel {
            width: 100%;
            max-width: 800px;
            background-color: #2A1A15;
            padding: 20px;
            margin-top: 20px;
            border-radius: 15px;
            border: 3px solid #4A2F2A;
            display: none;
            margin-bottom: 30px;
            border-top: 2px solid #FF6B35;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 15px rgba(255, 107, 53, 0.2);
        }

        .config-panel.open {
            display: block;
        }

        .config-item {
            margin-bottom: 15px;
        }

        .config-item label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #FF8C5A;
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .slider-container span {
            min-width: 30px;
            text-align: right;
            color: #FFA15A;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
            cursor: pointer;
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: #3A2520;
            outline: none;
            border: 1px solid #4A2F2A;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF6B35;
            cursor: pointer;
            border: 1px solid #7A1C00;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #FF6B35;
            cursor: pointer;
            border: 1px solid #7A1C00;
        }

        input[type="text"], input[type="number"] {
            padding: 8px;
            border: 1px solid #4A2F2A;
            background-color: #3A2520;
            color: white;
            border-radius: 4px;
            width: 100%;
            max-width: 300px;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
        }

        input[type="text"]:focus, input[type="number"]:focus {
            outline: none;
            border-color: #FF6B35;
            box-shadow: 0 0 8px rgba(255, 107, 53, 0.6);
        }

        .color-picker {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 8px;
        }

        .color-option {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .color-option:hover {
            transform: scale(1.2);
            border-color: white;
        }

        button {
            padding: 10px 15px;
            background-color: #FF6B35;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Comic Sans MS', 'Chalkboard SE', 'Marker Felt', sans-serif;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0px 3px 0px #7A1C00, 0px 4px 6px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.3);
        }

        button:hover {
            background-color: #FF8C5A;
            transform: translateY(-2px);
            box-shadow: 0px 5px 0px #7A1C00, 0px 7px 10px rgba(0, 0, 0, 0.3);
        }

        button:active {
            transform: translateY(1px);
            box-shadow: 0px 2px 0px #7A1C00, 0px 3px 4px rgba(0, 0, 0, 0.3);
        }

        #edit-config {
            background-color: #2196F3;
            box-shadow: 0px 3px 0px #0B5394, 0px 4px 6px rgba(0, 0, 0, 0.3);
        }

        #edit-config:hover {
            background-color: #4DABF5;
            box-shadow: 0px 5px 0px #0B5394, 0px 7px 10px rgba(0, 0, 0, 0.3);
        }

        #edit-config:active {
            box-shadow: 0px 2px 0px #0B5394, 0px 3px 4px rgba(0, 0, 0, 0.3);
        }

        #edit-config.active {
            background-color: #F44336;
            box-shadow: 0px 3px 0px #B71C1C, 0px 4px 6px rgba(0, 0, 0, 0.3);
        }

        #edit-config.active:hover {
            background-color: #FF5252;
            box-shadow: 0px 5px 0px #B71C1C, 0px 7px 10px rgba(0, 0, 0, 0.3);
        }

        .hole-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2A1A15;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            display: none;
            border: 2px solid #4A2F2A;
        }

        .hole-editor.open {
            display: block;
        }

        .hole-editor h3 {
            margin-bottom: 15px;
            text-align: center;
            color: #FF8C5A;
        }

        .hole-editor-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .peg-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2A1A15;
            padding: 20px;
            border-radius: 10px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            display: none;
            border: 2px solid #4A2F2A;
            width: 280px;
        }

        .peg-editor.open {
            display: block;
        }

        .peg-editor h3 {
            margin-bottom: 15px;
            text-align: center;
            color: #FF8C5A;
        }

        .peg-editor-content {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .peg-editor-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 15px;
        }

        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 99;
            display: none;
        }

        .overlay.open {
            display: block;
        }

        .sound-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-top: 15px;
            justify-content: center;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .toggle-label {
            color: #FFA15A;
            font-size: 1rem;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 22px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #3A2520;
            border: 2px solid #4A2F2A;
            transition: .4s;
            border-radius: 22px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 2px;
            background-color: #FF6B35;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #2A1A15;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .editor-help {
            color: #FF8C5A;
            margin: 10px 0;
            font-style: italic;
            text-align: center;
            font-size: 0.9rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.7; }
            50% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); opacity: 0.7; }
        }

        .win-display {
            animation: glow 0.5s ease-in-out;
            pointer-events: none;
            font-size: 1.8rem;
            font-weight: bold;
            color: #FFD700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.7);
        }
        
        @keyframes glow {
            0% { filter: brightness(1); }
            50% { filter: brightness(1.5) drop-shadow(0 0 10px #FF6B35); }
            100% { filter: brightness(1); }
        }
        
        /* Final Score Display */
        .final-score-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.8s ease;
        }
        
        .final-score-overlay.visible {
            opacity: 1;
            pointer-events: auto;
        }
        
        .final-score-container {
            background: linear-gradient(to bottom, #3B1D15, #2C1B18);
            padding: 30px 40px;
            border-radius: 15px;
            text-align: center;
            border: 4px solid #FF6B35;
            box-shadow: 0 0 30px rgba(255, 107, 53, 0.7), inset 0 0 20px rgba(255, 107, 53, 0.3);
            transform: scale(0.9);
            transition: transform 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .final-score-overlay.visible .final-score-container {
            transform: scale(1);
        }
        
        .final-score-title {
            font-size: 2.5rem;
            margin-bottom: 20px;
            color: #FF6B35;
            text-shadow: 0 0 15px rgba(255, 107, 53, 0.8), 3px 3px 0px #7A1C00;
        }
        
        .final-score-value {
            font-size: 4rem;
            font-weight: bold;
            margin: 20px 0;
            color: #FFC107;
            text-shadow: 0 0 15px rgba(255, 193, 7, 0.8), 0 0 10px rgba(255, 107, 53, 0.6);
        }
        
        .final-score-prefix {
            font-size: 2rem;
            color: #FFA15A;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
            margin-bottom: 10px;
        }
        
        .final-score-buttons {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        
        .final-score-btn {
            padding: 12px 25px;
            font-size: 1.2rem;
        }

        /* Fire text effect for score prefix */
        .fire-text {
            text-shadow: 0 -0.05em 0.2em #FFF, 0.01em -0.02em 0.15em #FE0, 0.01em -0.05em 0.15em #FC0, 0.02em -0.15em 0.2em #F90, 0.04em -0.2em 0.3em #F70, 0.05em -0.25em 0.4em #F70, 0.06em -0.2em 0.9em #F50, 0.1em -0.1em 1.0em #F40;
            color: #FFF;
        }
    </style>
</head>
<body>
    <div class="title-container">
        <h1 id="game-title">PLINKO BURN</h1>
        <div class="creator-credit">By Jozzuph</div>
    </div>

    <div class="score-container">
        <span id="score-prefix" class="fire-text">$SHIRO Burned:</span>
        <span id="score-value">0</span>
        <span class="ball-counter">Balls: <span id="ball-count">50</span> / <span id="max-balls">50</span></span>
    </div>

    <div class="game-container">
        <div class="game-header">
            <div class="multiplier-controls">
                <button class="multiplier-btn" data-multiplier="1">x1</button>
                <button class="multiplier-btn" data-multiplier="5">x5</button>
                <button class="multiplier-btn" data-multiplier="10">x10</button>
                <button class="multiplier-btn" data-multiplier="50">x50</button>
                <button class="multiplier-btn" data-multiplier="100">x100</button>
            </div>
        </div>
        
        <canvas id="plinko-board"></canvas>
        
        <div class="game-footer">
            <button id="reset-btn">Reset Game</button>
            <button id="edit-config">Edit Mode</button>
            
            <div class="sound-controls">
                <div class="toggle-container">
                    <span class="toggle-label">Sound FX</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="sound-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
        </div>
    </div>
        
    <!-- Modified config panel to appear below the game -->
    <div class="config-panel" id="config-panel">
        <div class="editor-help">Tip: In Edit Mode, click directly on pegs or bin separators to edit their properties!</div>
        
        <div class="config-item">
            <label for="game-title-input">Game Title:</label>
            <input type="text" id="game-title-input" value="PLINKO BURN">
        </div>
        
        <div class="config-item">
            <label for="score-prefix-input">Score Prefix:</label>
            <input type="text" id="score-prefix-input" value="$SHIRO Burned:">
        </div>
        
        <div class="config-item">
            <label for="max-balls-input">Total Balls Allowed:</label>
            <input type="number" id="max-balls-input" value="50" min="1" max="1000">
        </div>
        
        <div class="config-item">
            <label for="num-rows">Number of Rows (8-16):</label>
            <div class="slider-container">
                <input type="range" id="num-rows" min="8" max="16" value="16">
                <span id="num-rows-value">16</span>
            </div>
        </div>
        
        <div class="config-item">
            <label for="ball-size">Ball Size:</label>
            <div class="slider-container">
                <input type="range" id="ball-size" min="5" max="15" value="10">
                <span id="ball-size-value">10</span>
            </div>
        </div>
        
        <div class="config-item">
            <label for="peg-size">Peg Size:</label>
            <div class="slider-container">
                <input type="range" id="peg-size" min="3" max="10" value="6">
                <span id="peg-size-value">6</span>
            </div>
        </div>

        <div class="config-item">
            <label for="peg-bounciness">Peg Bounciness:</label>
            <div class="slider-container">
                <input type="range" id="peg-bounciness" min="0.5" max="1.5" step="0.1" value="1.0">
                <span id="peg-bounciness-value">1.0</span>
            </div>
        </div>
        
        <div class="config-item">
            <label for="ball-color">Ball Color:</label>
            <div class="color-picker" id="ball-color-picker">
                <div class="color-option" style="background-color: #FFC107;" data-color="#FFC107"></div>
                <div class="color-option" style="background-color: #FFEB3B;" data-color="#FFEB3B"></div>
                <div class="color-option" style="background-color: #FFD54F;" data-color="#FFD54F"></div>
                <div class="color-option" style="background-color: #FFCC80;" data-color="#FFCC80"></div>
                <div class="color-option" style="background-color: #FFF59D;" data-color="#FFF59D"></div>
            </div>
        </div>
        
        <div class="config-item">
            <label for="peg-color">Default Peg Color:</label>
            <div class="color-picker" id="peg-color-picker">
                <div class="color-option" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                <div class="color-option" style="background-color: #FF6B35;" data-color="#FF6B35"></div>
                <div class="color-option" style="background-color: #FFC15E;" data-color="#FFC15E"></div>
                <div class="color-option" style="background-color: #FF8C5A;" data-color="#FF8C5A"></div>
                <div class="color-option" style="background-color: #FF5151;" data-color="#FF5151"></div>
            </div>
        </div>
        
        <div style="display: flex; gap: 10px; margin-top: 15px; justify-content: center;">
            <button id="save-config">Save Configuration</button>
            <button id="cancel-config" style="background-color: #F44336; box-shadow: 0px 3px 0px #B71C1C, 0px 4px 6px rgba(0, 0, 0, 0.3);">Cancel</button>
        </div>
    </div>

    <div class="hole-editor" id="hole-editor">
        <h3>Edit Bin Value</h3>
        <input type="text" id="hole-value-input" placeholder="Value (e.g. 100, 1K, 1M, 1B)">
        <div class="hole-editor-buttons">
            <button id="save-hole-value">Save</button>
            <button id="cancel-hole-value" style="background-color: #F44336; box-shadow: 0px 3px 0px #B71C1C, 0px 4px 6px rgba(0, 0, 0, 0.3);">Cancel</button>
        </div>
    </div>

    <div class="peg-editor" id="peg-editor">
        <h3>Edit Peg Properties</h3>
        <div class="peg-editor-content">
            <label for="custom-peg-color-picker">Peg Color:</label>
            <div class="color-picker" id="custom-peg-color-picker">
                <div class="color-option" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
                <div class="color-option" style="background-color: #FF6B35;" data-color="#FF6B35"></div>
                <div class="color-option" style="background-color: #FFC15E;" data-color="#FFC15E"></div>
                <div class="color-option" style="background-color: #FF8C5A;" data-color="#FF8C5A"></div>
                <div class="color-option" style="background-color: #FF5151;" data-color="#FF5151"></div>
                <div class="color-option" style="background-color: #FFD700;" data-color="#FFD700"></div>
                <div class="color-option" style="background-color: #4CAF50;" data-color="#4CAF50"></div>
                <div class="color-option" style="background-color: #2196F3;" data-color="#2196F3"></div>
                <div class="color-option" style="background-color: #9C27B0;" data-color="#9C27B0"></div>
            </div>
            
            <label for="peg-bounce-custom">Bounciness:</label>
            <div class="slider-container">
                <input type="range" id="peg-bounce-custom" min="0.1" max="2.0" step="0.1" value="1.0">
                <span id="peg-bounce-custom-value">1.0</span>
            </div>
        </div>
        <div class="peg-editor-buttons">
            <button id="save-peg-properties">Save</button>
            <button id="cancel-peg-properties" style="background-color: #F44336; box-shadow: 0px 3px 0px #B71C1C, 0px 4px 6px rgba(0, 0, 0, 0.3);">Cancel</button>
        </div>
    </div>

    <div class="overlay" id="overlay"></div>
    
    <!-- Add Final Score Overlay -->
    <div class="final-score-overlay" id="final-score-overlay">
        <div class="final-score-container">
            <div class="final-score-prefix" id="final-score-prefix">$SHIRO Burned:</div>
            <div class="final-score-value" id="final-score-value">0</div>
            <div class="final-score-buttons">
                <button class="final-score-btn" id="play-again-btn">Play Again</button>
            </div>
        </div>
    </div>

    <script>
        // Game Configuration
        const config = {
            rows: 16,
            holeValues: [],
            currentMultiplier: 1,
            ballColor: '#FFC107',
            pegColor: '#FF6B35',
            backgroundColor: '#241914',
            gameTitle: "PLINKO BURN",
            scorePrefix: "$SHIRO Burned:",
            score: 0,
            ballSize: 10,
            pegSize: 6,
            pegBounciness: 1.0,
            maxBalls: 50,
            ballsRemaining: 50,
            soundEnabled: true,
            editMode: false,
            customPegs: {},  // Store custom peg properties
            physics: {
                gravity: 0.15,   // Decreased from 0.18 to make upward bounces more effective
                bounce: 0.8,     // Increased from 0.75 for more lively bounces
                friction: 0.97   // Slightly decreased to maintain momentum longer
            }
        };

        // Initialize default hole values - higher at edges, lower in middle
        function initHoleValues() {
            config.holeValues = [];
            
            for (let i = 0; i < config.rows; i++) {
                let value;
                
                // Determine value based on position (higher at edges, lower in middle)
                if (i === 0 || i === config.rows - 1) {
                    value = '100B'; // Doubled from 50B - Highest value at the edges
                } else {
                    // Calculate distance from center (normalized 0-1)
                    const center = (config.rows - 1) / 2;
                    const distFromCenter = Math.abs(i - center) / center;
                    
                    // Values decrease toward the center (all doubled)
                    if (distFromCenter > 0.8) {
                        value = '40B';  // Doubled from 20B
                    } else if (distFromCenter > 0.6) {
                        value = '20B';  // Doubled from 10B
                    } else if (distFromCenter > 0.4) {
                        value = '10B';  // Doubled from 5B
                    } else if (distFromCenter > 0.2) {
                        value = '2B';   // Doubled from 1B
                    } else {
                        value = '1B';   // Doubled from 500M
                    }
                }
                
                config.holeValues.push(value);
            }
        }

        // Game Elements
        const canvas = document.getElementById('plinko-board');
        const ctx = canvas.getContext('2d');
        const editConfigBtn = document.getElementById('edit-config');
        const configPanel = document.getElementById('config-panel');
        const saveConfigBtn = document.getElementById('save-config');
        const cancelConfigBtn = document.getElementById('cancel-config');
        const resetBtn = document.getElementById('reset-btn');
        const numRowsInput = document.getElementById('num-rows');
        const numRowsValue = document.getElementById('num-rows-value');
        const ballSizeInput = document.getElementById('ball-size');
        const ballSizeValue = document.getElementById('ball-size-value');
        const pegSizeInput = document.getElementById('peg-size');
        const pegSizeValue = document.getElementById('peg-size-value');
        const pegBouncinessInput = document.getElementById('peg-bounciness');
        const pegBouncinessValue = document.getElementById('peg-bounciness-value');
        const maxBallsInput = document.getElementById('max-balls-input');
        const multiplierBtns = document.querySelectorAll('.multiplier-btn');
        const gameTitleElement = document.getElementById('game-title');
        const gameTitleInput = document.getElementById('game-title-input');
        const scorePrefixElement = document.getElementById('score-prefix');
        const scorePrefixInput = document.getElementById('score-prefix-input');
        const scoreValueElement = document.getElementById('score-value');
        const ballCountElement = document.getElementById('ball-count');
        const maxBallsElement = document.getElementById('max-balls');
        const holeEditor = document.getElementById('hole-editor');
        const holeValueInput = document.getElementById('hole-value-input');
        const saveHoleValueBtn = document.getElementById('save-hole-value');
        const cancelHoleValueBtn = document.getElementById('cancel-hole-value');
        const pegEditor = document.getElementById('peg-editor');
        const pegBounceCustomInput = document.getElementById('peg-bounce-custom');
        const pegBounceCustomValue = document.getElementById('peg-bounce-custom-value');
        const savePegPropertiesBtn = document.getElementById('save-peg-properties');
        const cancelPegPropertiesBtn = document.getElementById('cancel-peg-properties');
        const overlay = document.getElementById('overlay');
        const soundToggle = document.getElementById('sound-toggle');
        const finalScoreOverlay = document.getElementById('final-score-overlay');
        const finalScorePrefix = document.getElementById('final-score-prefix');
        const finalScoreValue = document.getElementById('final-score-value');
        const playAgainBtn = document.getElementById('play-again-btn');

        // Game State
        let balls = [];
        let pegs = [];
        let bins = [];
        let animationId;
        let scale = 1;
        let currentEditingBinIndex = -1;
        let currentEditingPeg = null;
        let customPegColor = config.pegColor;
        let audioContext;
        let dropInterval = null;

        // Fixed base values for game dimensions - this is the reference size
        const BASE_WIDTH = 800;
        // Adjusted to create more horizontal space for pegs
        const BASE_HEIGHT_PER_ROW = 42; // Reduced from 50 to ensure all pegs are visible

        // Initialize the game
        function initGame() {
            // Initialize audio context
            initAudio();
            
            // Set canvas dimensions and calculate scale
            resizeCanvas();
            
            // Initialize hole values if empty
            if (config.holeValues.length === 0) {
                initHoleValues();
            }
            
            // Create pegs and bins
            createPegsAndBins();
            
            // Update UI with current configuration
            updateUI();
            
            // Start the game loop
            gameLoop();
        }

        // Initialize audio context
        function initAudio() {
            try {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            } catch (e) {
                console.warn('AudioContext not supported');
            }
        }

        // Update UI elements with current configuration
        function updateUI() {
            gameTitleElement.textContent = config.gameTitle;
            scorePrefixElement.textContent = config.scorePrefix;
            scoreValueElement.textContent = formatLargeNumber(config.score);
            ballCountElement.textContent = config.ballsRemaining;
            maxBallsElement.textContent = config.maxBalls;
            
            // Update button states based on remaining balls
            updateButtonStates();
        }

        // Update button states based on remaining balls
        function updateButtonStates() {
            multiplierBtns.forEach(btn => {
                const multiplier = parseInt(btn.dataset.multiplier);
                
                // Instead of disabling buttons, mark them with a class for styling
                if (multiplier > config.ballsRemaining) {
                    btn.classList.add('low-balls');
                } else {
                    btn.classList.remove('low-balls');
                }
                
                // No longer disabling buttons
                btn.disabled = false;
            });
        }

        // Resize canvas while maintaining aspect ratio and scaling for row count
        function resizeCanvas() {
            const container = canvas.parentElement;
            const containerWidth = container.clientWidth;
            
            // Calculate dynamic height based on number of rows
            // Add more vertical space to ensure all pegs fit
            const baseHeight = BASE_HEIGHT_PER_ROW * (config.rows + 2);
            
            // Calculate scale relative to base width
            scale = containerWidth / BASE_WIDTH;
            
            // Set canvas dimensions
            canvas.width = containerWidth;
            canvas.height = baseHeight * scale;
        }

        // Create pegs in a pyramid pattern and bins at the bottom
        function createPegsAndBins() {
            pegs = [];
            bins = [];
            
            const pegSpacing = BASE_HEIGHT_PER_ROW * scale;
            const pegRadius = config.pegSize * scale;
            
            const startX = canvas.width / 2;
            const startY = pegSpacing * 1.5;
            
            // Create pegs
            for (let row = 0; row < config.rows; row++) {
                const numPegs = row + 3; // Start with 3 pegs in the first row
                const rowWidth = (numPegs - 1) * pegSpacing;
                const offsetX = startX - rowWidth / 2;
                
                for (let col = 0; col < numPegs; col++) {
                    const pegId = `peg-${row}-${col}`;
                    const customPeg = config.customPegs[pegId];
                    
                    pegs.push({
                        x: offsetX + col * pegSpacing,
                        y: startY + row * pegSpacing,
                        radius: pegRadius,
                        row: row,
                        col: col,
                        id: pegId,
                        color: customPeg ? customPeg.color : config.pegColor,
                        bounciness: customPeg ? customPeg.bounciness : config.pegBounciness
                    });
                }
            }
            
            // Create bins as evenly spaced dividers
            const binY = startY + config.rows * pegSpacing + pegSpacing / 2;
            const numBins = config.rows;
            const binSpacing = canvas.width / numBins;
            
            for (let i = 0; i <= numBins; i++) {
                bins.push({
                    x: i * binSpacing,
                    y: binY,
                    index: Math.min(i, numBins - 1)
                });
            }
        }

        // Initial ball drop with larger random offset for better ball distribution
        function dropBall() {
            if (config.ballsRemaining <= 0) return false;
            
            // Resume AudioContext if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            const ballRadius = config.ballSize * scale;
            
            // Add more random initial conditions to prevent sticking
            // Wider variation in starting position
            const randomXOffset = (Math.random() * 10 - 5) * scale;
            // Random initial velocity for more varied paths
            const initialXVelocity = (Math.random() * 0.8 - 0.4) * scale;
            const randomYVelocity = Math.random() * scale + 0.3 * scale;
            
            const ball = {
                x: canvas.width / 2 + randomXOffset,
                y: BASE_HEIGHT_PER_ROW * scale, // Start position above first peg
                radius: ballRadius,
                velocityX: initialXVelocity, 
                velocityY: randomYVelocity,
                landed: false,
                binIndex: -1,
                lastPegHit: null, // Track last peg hit to prevent multiple collisions
                stuckFrames: 0 // Counter to detect if ball is stuck
            };
            
            balls.push(ball);
            config.ballsRemaining--;
            
            // Play ball drop sound
            playBallDropSound();
            
            // Update UI
            ballCountElement.textContent = config.ballsRemaining;
            updateButtonStates();
            
            return true;
        }

        // Drop multiple balls if available
        function dropMultipleBalls(count) {
            // Use as many balls as available, up to requested count
            const ballsToUse = Math.min(count, config.ballsRemaining);
            if (ballsToUse <= 0) return;
            
            // Initialize audio context on first interaction
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            for (let i = 0; i < ballsToUse; i++) {
                setTimeout(() => {
                    const ballDropped = dropBall();
                    
                    // Check if this was the last ball
                    if (config.ballsRemaining === 0) {
                        // Set a timeout to show the final score after the last ball settles
                        setTimeout(showFinalScore, 2500);
                    }
                }, i * 100); // Delay each ball drop slightly
            }
        }
        
        // Show final score overlay when the game is over
        function showFinalScore() {
            // Make sure all balls have settled or been removed
            if (balls.length > 0) {
                // If there are still balls in play, wait a bit longer
                setTimeout(showFinalScore, 1000);
                return;
            }
            
            // Update final score display
            finalScorePrefix.textContent = config.scorePrefix;
            finalScoreValue.textContent = formatLargeNumber(config.score);
            
            // Show the overlay
            finalScoreOverlay.classList.add('visible');
        }

        // Update ball positions and check for collisions
        function updateBalls() {
            for (let i = balls.length - 1; i >= 0; i--) {
                const ball = balls[i];
                
                if (ball.landed) {
                    if (ball.y > canvas.height + ball.radius * 4) {
                        // Remove ball once it's off-screen
                        balls.splice(i, 1);
                    } else {
                        // Continue falling after landing
                        ball.y += 5 * scale;
                    }
                    continue;
                }
                
                // Track previous position to detect sticking
                const prevX = ball.x;
                const prevY = ball.y;
                
                // Apply gravity (scaled)
                ball.velocityY += config.physics.gravity * scale;
                
                // Apply friction
                ball.velocityX *= config.physics.friction;
                ball.velocityY *= config.physics.friction;
                
                // Update position
                ball.x += ball.velocityX;
                ball.y += ball.velocityY;
                
                // Improved stuck detection with lower threshold and quicker response
                if (Math.abs(ball.x - prevX) < 0.15 * scale && 
                    Math.abs(ball.y - prevY) < 0.15 * scale &&
                    ball.y < bins[0].y - ball.radius * 2) {
                    
                    ball.stuckFrames++;
                    
                    // Detect stuck balls more quickly and apply stronger impulse
                    if (ball.stuckFrames > 15) { // 15 frames = ~0.25 seconds (faster detection)
                        // Strong impulse in a random direction with bias downward
                        ball.velocityX += (Math.random() * 2.5 - 1.25) * scale;
                        ball.velocityY += Math.random() * scale + 1.0 * scale; // Much stronger downward push
                        
                        // For severe cases, teleport the ball slightly
                        if (ball.stuckFrames > 30) {
                            // Small teleport to escape the stuck position
                            ball.x += (Math.random() * 2 - 1) * ball.radius * 0.5;
                            ball.y += ball.radius * 0.5; // Small nudge downward
                        }
                        
                        ball.stuckFrames = 0;
                    }
                } else {
                    ball.stuckFrames = 0;
                }
                
                // Special handling for top row - add extra random motion to avoid getting stuck
                if (ball.y < BASE_HEIGHT_PER_ROW * 3 * scale && Math.random() < 0.1) {
                    // Occasional random impulse near the top of the board
                    ball.velocityX += (Math.random() * 1.0 - 0.5) * scale;
                    // Occasional slight upward bounce
                    if (Math.random() < 0.3) {
                        ball.velocityY -= 0.3 * scale;
                    }
                }
                
                // Apply a minimum velocity to keep balls moving
                const minVelocity = 0.4 * scale;  // Increased from 0.3 to 0.4
                const currentVelocity = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                if (currentVelocity < minVelocity && !ball.landed && ball.y < bins[0].y - ball.radius * 2) {
                    // Calculate multiplier needed to reach min velocity
                    const multiplier = minVelocity / (currentVelocity || 0.01); // Avoid division by zero
                    ball.velocityX *= multiplier;
                    ball.velocityY *= multiplier;
                    
                    // Ensure some downward momentum
                    if (ball.velocityY < 0.1 * scale) {
                        ball.velocityY += 0.1 * scale;
                    }
                }
                
                // Check for peg collisions with improved interaction
                let collided = false;
                
                for (const peg of pegs) {
                    // Skip if this is the last peg we hit (prevents multiple collisions with same peg)
                    if (peg === ball.lastPegHit) continue;
                    
                    const dx = ball.x - peg.x;
                    const dy = ball.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = ball.radius + peg.radius;
                    
                    if (distance < minDistance) {
                        // Collision detected
                        collided = true;
                        ball.lastPegHit = peg; // Remember this peg
                        
                        // Calculate the angle of collision
                        const angle = Math.atan2(dy, dx);
                        
                        // Improved top hit detection with broader range
                        const isTopHit = angle > -Math.PI/3 && angle < Math.PI/3;
                        
                        // Random direction for extra push
                        const randomDirection = Math.random() > 0.5 ? 1 : -1;
                        
                        // Adjust overlap and push more significantly if hitting top
                        const overlap = minDistance - distance;
                        const pushFactor = isTopHit ? 2.0 : 1.1;  // Increased from 1.5 to 2.0
                        
                        // Move the ball out of the peg with more push
                        ball.x += Math.cos(angle) * overlap * pushFactor;
                        ball.y += Math.sin(angle) * overlap * pushFactor;
                        
                        // Add extra horizontal push when hitting top - much stronger now
                        if (isTopHit) {
                            // Stronger sideways push (increased from 0.3-0.7 to 0.8-1.5)
                            ball.x += randomDirection * (0.8 + Math.random() * 0.7) * scale;
                            
                            // More likely and stronger upward bounce
                            if (Math.random() < 0.7) {  // Increased probability from 0.4 to 0.7
                                ball.velocityY -= (0.5 + Math.random() * 0.3) * scale;  // Increased from 0.3 to 0.5-0.8
                            }
                        }
                        
                        // More variation for top hits to prevent sticking
                        const angleVariation = isTopHit ? 0.7 : 0.3;
                        // Slightly bias the deflection angle to avoid getting stuck on top
                        let bounceAngle;
                        if (isTopHit) {
                            // Calculate a bounce angle biased to same random direction
                            const bias = randomDirection * (0.2 + Math.random() * 0.3);
                            bounceAngle = angle + bias + (Math.random() * angleVariation * 2 - angleVariation);
                        } else {
                            bounceAngle = angle + (Math.random() * angleVariation * 2 - angleVariation);
                        }
                        
                        // Calculate speed and apply increased bounciness
                        const speed = Math.sqrt(ball.velocityX * ball.velocityX + ball.velocityY * ball.velocityY);
                        const pegBounce = peg.bounciness; // Use per-peg bounciness
                        // More random bounce factor for liveliness
                        const randomBounceFactor = config.physics.bounce + (Math.random() * 0.3 - 0.1);
                        const bounceFactor = randomBounceFactor * pegBounce;
                        
                        // Apply the bounce effect
                        ball.velocityX = Math.cos(bounceAngle) * speed * bounceFactor;
                        ball.velocityY = Math.sin(bounceAngle) * speed * bounceFactor;
                        
                        // Add more horizontal motion to prevent sticking
                        ball.velocityX += (Math.random() * 0.8 - 0.4) * scale;
                        
                        // If hitting top, add substantially more downward force and horizontal motion
                        if (isTopHit) {
                            // More likely for a significant upward bounce now
                            if (Math.random() < 0.6) {  // Increased probability for upward bounce
                                // Add stronger downward force most of the time
                                ball.velocityY += 0.8 * scale; 
                            } else {
                                // Stronger upward bounce (increased from -0.2 to -0.5)
                                ball.velocityY -= (0.5 + Math.random() * 0.3) * scale; 
                            }
                            
                            // Add significantly more horizontal movement in random direction
                            // Increased from 0.5-0.9 to 0.8-1.4
                            ball.velocityX += randomDirection * (0.8 + Math.random() * 0.6) * scale;
                            
                            // Special case for first row pins (top pins)
                            if (peg.row === 0) {
                                // Extra horizontal force and more frequent upward bounce for first row
                                ball.velocityX += randomDirection * 0.8 * scale;  // Increased from 0.4 to 0.8
                                
                                // Much higher chance of upward bounce for the first row
                                if (Math.random() < 0.7) {  // Increased from 0.3 to 0.7
                                    // Stronger upward force (increased from -0.3 to -0.6)
                                    ball.velocityY -= (0.6 + Math.random() * 0.3) * scale;
                                }
                            }
                        }
                        
                        // Visual feedback - flash the peg
                        peg.isFlashing = true;
                        
                        // Play sound for peg hit with velocity-based pitch
                        const hitVelocity = Math.sqrt(
                            Math.pow(ball.velocityX, 2) + 
                            Math.pow(ball.velocityY, 2)
                        );
                        playPegHitSound(200 + hitVelocity * 100);
                        
                        // Only process one collision per frame to prevent energy gain
                        break;
                    }
                }
                
                // Clear lastPegHit if no collision this frame
                if (!collided) {
                    ball.lastPegHit = null;
                }
                
                // Check for wall collisions
                if (ball.x - ball.radius < 0) {
                    ball.x = ball.radius;
                    ball.velocityX = -ball.velocityX * config.physics.bounce;
                } else if (ball.x + ball.radius > canvas.width) {
                    ball.x = canvas.width - ball.radius;
                    ball.velocityX = -ball.velocityX * config.physics.bounce;
                }
                
                // Check if ball has reached the bottom (bin line)
                if (ball.y > bins[0].y - ball.radius) {
                    // Find which bin the ball landed in
                    for (let b = 0; b < bins.length - 1; b++) {
                        if (ball.x >= bins[b].x && ball.x < bins[b+1].x) {
                            ball.binIndex = b;
                            ball.landed = true;
                            
                            // Add to score
                            addToScore(config.holeValues[b]);
                            
                            // Show winning animation
                            const midX = (bins[b].x + bins[b+1].x) / 2;
                            showWinningAnimation(config.holeValues[b], midX, bins[0].y);
                            
                            // Play bucket sound
                            playBucketSound(b);
                            
                            break;
                        }
                    }
                    
                    // Handle edge case for rightmost position
                    if (!ball.landed && ball.x >= bins[bins.length-1].x) {
                        const lastIndex = config.holeValues.length - 1;
                        ball.binIndex = lastIndex;
                        ball.landed = true;
                        
                        // Add to score
                        addToScore(config.holeValues[lastIndex]);
                        
                        // Show winning animation
                        showWinningAnimation(config.holeValues[lastIndex], ball.x, bins[0].y);
                        
                        // Play bucket sound
                        playBucketSound(lastIndex);
                    }
                }
            }
        }

        // Reset the game
        function resetGame() {
            // Clear any intervals
            if (dropInterval) {
                clearInterval(dropInterval);
                dropInterval = null;
            }
            
            // Hide final score overlay if visible
            finalScoreOverlay.classList.remove('visible');
            
            // Reset game state
            config.score = 0;
            config.ballsRemaining = config.maxBalls;
            balls = [];
            
            // Reset UI
            scoreValueElement.textContent = '0';
            ballCountElement.textContent = config.ballsRemaining;
            
            // Update button states
            updateButtonStates();
            
            // Reset first multiplier button to active
            multiplierBtns.forEach(btn => btn.classList.remove('active'));
            document.querySelector('.multiplier-btn[data-multiplier="1"]').classList.add('active');
        }

        // Parse value notation (1K, 1M, 1B, etc.) to numeric value
        function parseValueNotation(valueStr) {
            const value = valueStr.toString().trim();
            const numericPart = parseFloat(value.replace(/[^0-9.]/g, '')) || 0;
            
            if (value.includes('K')) {
                return numericPart * 1000;
            } else if (value.includes('M')) {
                return numericPart * 1000000;
            } else if (value.includes('B')) {
                return numericPart * 1000000000;
            } else if (value.includes('T')) {
                return numericPart * 1000000000000;
            } else if (value.includes('Q')) {
                return numericPart * 1000000000000000;
            }
            
            return numericPart;
        }

        // Add value to score
        function addToScore(valueStr) {
            const scoreValue = parseValueNotation(valueStr);
            config.score += scoreValue;
            scoreValueElement.textContent = formatLargeNumber(config.score);
        }

        // Format large number to include K, M, B, T, Q
        function formatLargeNumber(num) {
            if (num >= 1000000000000000) {
                return (num / 1000000000000000).toFixed(1) + 'Q';
            } else if (num >= 1000000000000) {
                return (num / 1000000000000).toFixed(1) + 'T';
            } else if (num >= 1000000000) {
                return (num / 1000000000).toFixed(1) + 'B';
            } else if (num >= 1000000) {
                return (num / 1000000).toFixed(1) + 'M';
            } else if (num >= 1000) {
                return (num / 1000).toFixed(1) + 'K';
            }
            return num.toString();
        }

        // Show winning animation
        function showWinningAnimation(value, x, y) {
            const gameContainer = document.querySelector('.game-container');
            const rect = canvas.getBoundingClientRect();
            
            // Convert canvas coordinates to DOM coordinates
            const domX = rect.left + (x / canvas.width) * rect.width;
            const domY = rect.top + (y / canvas.height) * rect.height;
            
            const winDisplay = document.createElement('div');
            winDisplay.textContent = value;
            winDisplay.className = 'win-display';
            winDisplay.style.position = 'fixed';
            winDisplay.style.top = domY + 'px';
            winDisplay.style.left = domX + 'px';
            winDisplay.style.transform = 'translate(-50%, -50%)';
            winDisplay.style.fontSize = (1.5 * scale) + 'rem';
            winDisplay.style.fontWeight = 'bold';
            winDisplay.style.color = '#FFC107';
            winDisplay.style.textShadow = '0 0 10px rgba(255, 193, 7, 0.8), 0 0 20px rgba(255, 193, 7, 0.5)';
            winDisplay.style.zIndex = '100';
            
            document.body.appendChild(winDisplay);
            
            // Animate and remove
            setTimeout(() => {
                winDisplay.style.opacity = '0';
                winDisplay.style.transform = 'translate(-50%, -150%)';
                setTimeout(() => {
                    winDisplay.remove();
                }, 1000);
            }, 1000);
        }

        // Sound effects
        function playBallDropSound() {
            if (!config.soundEnabled || !audioContext) return;
            const frequency = 400 + Math.random() * 100;
            playSound(frequency, 0.03, 'sine', 0.1);
        }

        function playPegHitSound(frequency) {
            if (!config.soundEnabled || !audioContext) return;
            playSound(frequency, 0.05, 'triangle', 0.08);
        }

        function playBucketSound(bucketIndex) {
            if (!config.soundEnabled || !audioContext) return;
            
            // Calculate how far from center the bucket is
            const middleIndex = Math.floor((config.rows - 1) / 2);
            const distFromCenter = Math.abs(bucketIndex - middleIndex);
            const isMiddle = distFromCenter === 0;
            const isAdjacent = distFromCenter === 1;
            
            // Sound intensity based on position
            let volume = 0.1;
            let intensity = 1;
            
            if (isMiddle) {
                // Center bucket - most intense sound
                volume = 0.3;
                intensity = 2;
            } else if (isAdjacent) {
                // Adjacent buckets - enhanced sound
                volume = 0.2;
                intensity = 1.5;
            }
            
            // Base frequency depends on position (lower/deeper sounds for center)
            const baseFreq = isMiddle ? 80 : isAdjacent ? 120 : 180;
            
            // Play sizzle sound with varying intensity
            playSizzleSound(baseFreq, volume, intensity);
        }

        function playSound(frequency, volume, type = 'sine', duration = 0.3) {
            if (!config.soundEnabled || !audioContext) return;
            
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.type = type;
                oscillator.frequency.value = frequency;
                gainNode.gain.value = volume;
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.start();
                
                gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);
                
                setTimeout(() => {
                    oscillator.stop();
                }, duration * 1000);
            } catch (e) {
                console.warn('Error playing sound', e);
            }
        }

        function playSizzleSound(baseFreq, volume, intensity = 1) {
            if (!config.soundEnabled || !audioContext) return;
            
            try {
                // Create noise
                const bufferSize = 2 * audioContext.sampleRate;
                const noiseBuffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const output = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = Math.random() * 2 - 1;
                }
                
                const noise = audioContext.createBufferSource();
                noise.buffer = noiseBuffer;
                
                // Create filter for sizzle effect
                const filter = audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = baseFreq;
                filter.Q.value = 1;
                
                // More intense filter for center buckets
                if (intensity > 1.3) {
                    // Add a second filter for more character
                    const filter2 = audioContext.createBiquadFilter();
                    filter2.type = 'lowpass';
                    filter2.frequency.value = baseFreq * 2;
                    
                    // Add distortion for intense center bucket sounds
                    const distortion = audioContext.createWaveShaper();
                    distortion.curve = makeDistortionCurve(intensity * 50);
                    
                    // Create gain for volume control
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = volume;
                    
                    // Connect nodes with distortion for intense sounds
                    noise.connect(filter);
                    filter.connect(filter2);
                    filter2.connect(distortion);
                    distortion.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // More complex envelope for intense sounds
                    const now = audioContext.currentTime;
                    gainNode.gain.setValueAtTime(0, now);
                    gainNode.gain.linearRampToValueAtTime(volume, now + 0.05);
                    gainNode.gain.setValueAtTime(volume, now + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(volume * 0.8, now + 0.2);
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, now + 0.7);
                    
                    // Start noise
                    noise.start();
                    
                    // Stop after duration
                    setTimeout(() => {
                        noise.stop();
                    }, 700);
                } else {
                    // Create gain for volume control
                    const gainNode = audioContext.createGain();
                    gainNode.gain.value = volume;
                    
                    // Connect nodes
                    noise.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    // Start noise and ramp down volume
                    noise.start();
                    gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + 0.6);
                    
                    // Stop after duration
                    setTimeout(() => {
                        noise.stop();
                    }, 600);
                }
            } catch (e) {
                console.warn('Error playing sizzle sound', e);
            }
        }

        // Creates a distortion curve for sound effects
        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n_samples = 44100;
            const curve = new Float32Array(n_samples);
            const deg = Math.PI / 180;
            
            for (let i = 0; i < n_samples; ++i) {
                const x = i * 2 / n_samples - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            
            return curve;
        }

        // Open bin editor
        function openBinEditor(binIndex) {
            currentEditingBinIndex = binIndex;
            holeValueInput.value = config.holeValues[binIndex];
            
            holeEditor.classList.add('open');
            overlay.classList.add('open');
            
            holeValueInput.focus();
        }

        // Close bin editor
        function closeBinEditor() {
            holeEditor.classList.remove('open');
            overlay.classList.remove('open');
            currentEditingBinIndex = -1;
        }

        // Save bin value
        function saveBinValue() {
            if (currentEditingBinIndex >= 0) {
                const newValue = holeValueInput.value;
                config.holeValues[currentEditingBinIndex] = newValue;
            }
            closeBinEditor();
        }

        // Open peg editor
        function openPegEditor(peg) {
            currentEditingPeg = peg;
            
            // Set initial values in the editor
            pegBounceCustomInput.value = peg.bounciness;
            pegBounceCustomValue.textContent = peg.bounciness;
            
            // Select the current peg color in the picker
            const colorOptions = document.querySelectorAll('#custom-peg-color-picker .color-option');
            colorOptions.forEach(option => {
                if (option.dataset.color === peg.color) {
                    option.style.border = '2px solid white';
                    customPegColor = peg.color;
                } else {
                    option.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                }
            });
            
            // Show the editor
            pegEditor.classList.add('open');
            overlay.classList.add('open');
        }

        // Close peg editor
        function closePegEditor() {
            pegEditor.classList.remove('open');
            overlay.classList.remove('open');
            currentEditingPeg = null;
        }

        // Save peg properties
        function savePegProperties() {
            if (currentEditingPeg) {
                currentEditingPeg.color = customPegColor;
                currentEditingPeg.bounciness = parseFloat(pegBounceCustomInput.value);
                
                // Store custom properties in config
                config.customPegs[currentEditingPeg.id] = {
                    color: customPegColor,
                    bounciness: parseFloat(pegBounceCustomInput.value)
                };
            }
            closePegEditor();
        }

        // Check if click is near a bin divider or in a bin
        function checkBinClick(x, y) {
            const clickThreshold = 15 * scale;
            
            // Check if click is near the bin line
            if (Math.abs(y - bins[0].y) > clickThreshold) {
                return -1;
            }
            
            // Find the bin area that was clicked
            for (let i = 0; i < bins.length - 1; i++) {
                if (x >= bins[i].x && x < bins[i+1].x) {
                    return i;
                }
            }
            
            return -1;
        }

        // Check if click is on a peg
        function checkPegClick(x, y) {
            const clickThreshold = 15 * scale;
            
            for (const peg of pegs) {
                const distance = Math.sqrt(Math.pow(x - peg.x, 2) + Math.pow(y - peg.y, 2));
                if (distance < peg.radius + clickThreshold) {
                    return peg;
                }
            }
            
            return null;
        }

        // Draw the game
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = config.backgroundColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw pegs with glowing effect
            for (const peg of pegs) {
                // Draw glow
                const gradient = ctx.createRadialGradient(
                    peg.x, peg.y, 0,
                    peg.x, peg.y, peg.radius * 2
                );
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, peg.radius * 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw peg
                // If peg is flashing, use white, otherwise use its color
                ctx.fillStyle = peg.isFlashing ? '#FFFFFF' : peg.color;
                ctx.beginPath();
                ctx.arc(peg.x, peg.y, peg.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset flashing state
                if (peg.isFlashing) {
                    setTimeout(() => {
                        peg.isFlashing = false;
                    }, 100);
                }
            }
            
            // Draw bins with borders and dividers
            ctx.strokeStyle = '#FF6B35';
            ctx.lineWidth = 2 * scale;
            
            // Draw horizontal line at the bottom of the pegs
            ctx.beginPath();
            ctx.moveTo(0, bins[0].y);
            ctx.lineTo(canvas.width, bins[0].y);
            ctx.stroke();
            
            // Draw dividers and bin borders with vertical lines extending from bottom
            for (let i = 0; i < bins.length; i++) {
                const bin = bins[i];
                
                // Draw divider line - extend from bottom of canvas upward past bin line
                ctx.beginPath();
                ctx.moveTo(bin.x, canvas.height);
                ctx.lineTo(bin.x, bin.y - 20 * scale); // Extend slightly above the bin line
                ctx.stroke();
                
                // Draw bin border rectangles
                if (i < bins.length - 1) {
                    // Draw a slightly lighter rectangle for each bin area
                    ctx.fillStyle = 'rgba(255, 107, 53, 0.1)'; // Transparent orange-red
                    ctx.fillRect(bin.x, bin.y, bins[i+1].x - bin.x, canvas.height - bin.y);
                    
                    // Draw border for bin area
                    ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)'; // Semi-transparent orange-red
                    ctx.lineWidth = 1 * scale;
                    ctx.strokeRect(bin.x, bin.y, bins[i+1].x - bin.x, canvas.height - bin.y);
                    
                    // Reset stroke style
                    ctx.strokeStyle = '#FF6B35';
                    ctx.lineWidth = 2 * scale;
                }
            }
            
            // Draw bin values
            ctx.fillStyle = '#FFC107'; // Brighter color for values
            ctx.font = `bold ${14 * scale}px "Comic Sans MS", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            
            for (let i = 0; i < bins.length - 1; i++) {
                const midX = (bins[i].x + bins[i+1].x) / 2;
                
                // Add a small background for better visibility
                const valueText = config.holeValues[i];
                const textWidth = ctx.measureText(valueText).width;
                const textHeight = 14 * scale;
                const padding = 4 * scale;
                
                ctx.fillStyle = 'rgba(59, 39, 35, 0.7)'; // Semi-transparent background
                ctx.fillRect(
                    midX - textWidth/2 - padding, 
                    bins[0].y - textHeight - padding*2, 
                    textWidth + padding*2, 
                    textHeight + padding
                );
                
                // Draw value text
                ctx.fillStyle = '#FFC107';
                ctx.fillText(valueText, midX, bins[0].y - 5 * scale);
            }
            
            // Draw balls with shine effect
            for (const ball of balls) {
                // Base ball
                ctx.fillStyle = config.ballColor;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add shine effect
                const ballGradient = ctx.createRadialGradient(
                    ball.x - ball.radius / 2.5, ball.y - ball.radius / 2.5,
                    ball.radius / 10,
                    ball.x, ball.y,
                    ball.radius
                );
                ballGradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
                ballGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                ballGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                
                ctx.fillStyle = ballGradient;
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Debug: Draw indicator for stuck balls
                if (ball.stuckFrames > 15) {
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius + 4, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Game loop
        function gameLoop() {
            updateBalls();
            drawGame();
            animationId = requestAnimationFrame(gameLoop);
        }

        // Event Listeners
        window.addEventListener('resize', () => {
            resizeCanvas();
            createPegsAndBins();
        });

        multiplierBtns.forEach(btn => {
            btn.addEventListener('click', function() {
                // Don't check for disabled since we're not disabling buttons anymore
                
                // Update active state
                multiplierBtns.forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                // Get requested multiplier
                const requestedMultiplier = parseInt(this.dataset.multiplier);
                
                // Use as many balls as we have left, up to the requested multiplier
                config.currentMultiplier = Math.min(requestedMultiplier, config.ballsRemaining);
                
                // Drop the balls
                dropMultipleBalls(config.currentMultiplier);
            });
        });

        editConfigBtn.addEventListener('click', () => {
            config.editMode = !config.editMode;
            configPanel.classList.toggle('open', config.editMode);
            editConfigBtn.classList.toggle('active', config.editMode);
            editConfigBtn.textContent = config.editMode ? 'Close Editor' : 'Edit Mode';
            
            // Update input values
            gameTitleInput.value = config.gameTitle;
            scorePrefixInput.value = config.scorePrefix;
            numRowsInput.value = config.rows;
            numRowsValue.textContent = config.rows;
            ballSizeInput.value = config.ballSize;
            ballSizeValue.textContent = config.ballSize;
            pegSizeInput.value = config.pegSize;
            pegSizeValue.textContent = config.pegSize;
            pegBouncinessInput.value = config.pegBounciness;
            pegBouncinessValue.textContent = config.pegBounciness;
            maxBallsInput.value = config.maxBalls;
            
            // Select current color options
            document.querySelectorAll('#ball-color-picker .color-option').forEach(option => {
                if (option.dataset.color === config.ballColor) {
                    option.style.border = '2px solid white';
                } else {
                    option.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                }
            });
            
            document.querySelectorAll('#peg-color-picker .color-option').forEach(option => {
                if (option.dataset.color === config.pegColor) {
                    option.style.border = '2px solid white';
                } else {
                    option.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                }
            });
        });

        saveConfigBtn.addEventListener('click', () => {
            // Update configuration
            config.gameTitle = gameTitleInput.value;
            config.scorePrefix = scorePrefixInput.value;
            config.rows = parseInt(numRowsInput.value);
            config.ballSize = parseInt(ballSizeInput.value);
            config.pegSize = parseInt(pegSizeInput.value);
            config.pegBounciness = parseFloat(pegBouncinessInput.value);
            config.maxBalls = parseInt(maxBallsInput.value);
            
            // Update remaining balls if needed
            if (config.ballsRemaining > config.maxBalls) {
                config.ballsRemaining = config.maxBalls;
            }
            
            // Ensure hole values array has the right length
            while (config.holeValues.length < config.rows) {
                config.holeValues.push('100B');
            }
            if (config.holeValues.length > config.rows) {
                config.holeValues = config.holeValues.slice(0, config.rows);
            }
            
            // Resize and update game
            resizeCanvas();
            createPegsAndBins();
            updateUI();
            
            // Reset edit mode
            config.editMode = false;
            configPanel.classList.remove('open');
            editConfigBtn.classList.remove('active');
            editConfigBtn.textContent = 'Edit Mode';
        });

        cancelConfigBtn.addEventListener('click', () => {
            config.editMode = false;
            configPanel.classList.remove('open');
            editConfigBtn.classList.remove('active');
            editConfigBtn.textContent = 'Edit Mode';
        });

        numRowsInput.addEventListener('input', function() {
            numRowsValue.textContent = this.value;
        });

        ballSizeInput.addEventListener('input', function() {
            ballSizeValue.textContent = this.value;
        });

        pegSizeInput.addEventListener('input', function() {
            pegSizeValue.textContent = this.value;
        });
        
        pegBouncinessInput.addEventListener('input', function() {
            pegBouncinessValue.textContent = this.value;
        });
        
        pegBounceCustomInput.addEventListener('input', function() {
            pegBounceCustomValue.textContent = this.value;
        });

        saveHoleValueBtn.addEventListener('click', saveBinValue);
        cancelHoleValueBtn.addEventListener('click', closeBinEditor);

        savePegPropertiesBtn.addEventListener('click', savePegProperties);
        cancelPegPropertiesBtn.addEventListener('click', closePegEditor);

        // Listen for Enter key in hole value input
        holeValueInput.addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                saveBinValue();
            }
        });

        // Canvas click event for bin and peg editing
        canvas.addEventListener('click', function(e) {
            if (!config.editMode) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (canvas.width / rect.width);
            const y = (e.clientY - rect.top) * (canvas.height / rect.height);
            
            // Check for bin click
            const binIndex = checkBinClick(x, y);
            if (binIndex >= 0) {
                openBinEditor(binIndex);
                return;
            }
            
            // Check for peg click
            const peg = checkPegClick(x, y);
            if (peg) {
                openPegEditor(peg);
                return;
            }
        });

        // Reset button
        resetBtn.addEventListener('click', resetGame);
        
        // Play again button in final score overlay
        playAgainBtn.addEventListener('click', resetGame);

        // Sound toggle
        soundToggle.addEventListener('change', function() {
            config.soundEnabled = this.checked;
        });

        // Set up color pickers for ball and peg
        function setupColorPickers() {
            // Ball color picker
            document.querySelectorAll('#ball-color-picker .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const color = this.dataset.color;
                    config.ballColor = color;
                    
                    // Visual feedback
                    document.querySelectorAll('#ball-color-picker .color-option').forEach(o => {
                        o.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                    });
                    this.style.border = '2px solid white';
                });
            });
            
            // Default peg color picker
            document.querySelectorAll('#peg-color-picker .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    const color = this.dataset.color;
                    config.pegColor = color;
                    
                    // Visual feedback
                    document.querySelectorAll('#peg-color-picker .color-option').forEach(o => {
                        o.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                    });
                    this.style.border = '2px solid white';
                });
            });
            
            // Custom peg color picker in peg editor
            document.querySelectorAll('#custom-peg-color-picker .color-option').forEach(option => {
                option.addEventListener('click', function() {
                    customPegColor = this.dataset.color;
                    
                    // Visual feedback
                    document.querySelectorAll('#custom-peg-color-picker .color-option').forEach(o => {
                        o.style.border = '2px solid rgba(255, 255, 255, 0.2)';
                    });
                    this.style.border = '2px solid white';
                });
            });
        }

        // Start a continuous drop of balls with mouse/touch hold
        function startContinuousDrop() {
            if (dropInterval || config.ballsRemaining <= 0) return;
            
            // Resume AudioContext if suspended
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            dropBall(); // Drop first ball immediately
            
            dropInterval = setInterval(() => {
                if (config.ballsRemaining > 0) {
                    dropBall();
                } else {
                    stopContinuousDrop();
                }
            }, 200);
        }

        function stopContinuousDrop() {
            if (dropInterval) {
                clearInterval(dropInterval);
                dropInterval = null;
            }
        }

        // Set default active multiplier
        document.querySelector('.multiplier-btn[data-multiplier="1"]').classList.add('active');

        // Initialize the game on load
        window.addEventListener('load', () => {
            initGame();
            setupColorPickers();
            
            // Add event listeners for continuous drop on x1 button
            const dropBtn = document.querySelector('.multiplier-btn[data-multiplier="1"]');
            
            const handleDropStart = (e) => {
                e.preventDefault();
                startContinuousDrop();
            };
            
            const handleDropEnd = (e) => {
                if (e) e.preventDefault();
                stopContinuousDrop();
            };
            
            // Mouse events
            dropBtn.addEventListener('mousedown', handleDropStart);
            dropBtn.addEventListener('mouseup', handleDropEnd);
            dropBtn.addEventListener('mouseleave', handleDropEnd);
            
            // Touch events
            dropBtn.addEventListener('touchstart', handleDropStart, { passive: false });
            dropBtn.addEventListener('touchend', handleDropEnd, { passive: false });
            dropBtn.addEventListener('touchcancel', handleDropEnd, { passive: false });
            
            // Handle resume of audio context on first interaction
            document.body.addEventListener('click', function initAudioOnInteraction() {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                document.body.removeEventListener('click', initAudioOnInteraction);
            }, { once: true });
        });
    </script>
</body>
</html>
